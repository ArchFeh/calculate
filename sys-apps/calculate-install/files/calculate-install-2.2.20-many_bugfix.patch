diff --git pym/cl_distr.py pym/cl_distr.py
index 9045f76..057e50d 100644
--- pym/cl_distr.py
+++ pym/cl_distr.py
@@ -457,7 +457,6 @@ class Distributive(object, SignalInterrupt):
 
     def _removeDirectory(self,directory):
         """Remove directory and files contained in it"""
-        #print "removeDirectory:",directory
         try:
             removeDir(directory)
         except Exception, e:
@@ -566,8 +565,9 @@ class Distributive(object, SignalInterrupt):
         return None
 
 
-    def _mountToDirectory(self,file,directory,mountopts=""):
+    def _mountToDirectory(self,file,directory,mountopts="",count=2):
         """Mount squashfs to directory"""
+        NO_SUCH_DEVICE = 2816
         if isMount(directory):
             raise DistributiveError(_("Cann't mount to directory: %s\n")\
                                      %directory+ _("Directory already mounted"))
@@ -578,6 +578,12 @@ class Distributive(object, SignalInterrupt):
         if mountProcess.success():
             return True
         else:
+            # 2816 code return by mount if device is absent (update /dev by udev)
+            # try mount 3 times with interval 0.5 second
+            if mountProcess.returncode() == NO_SUCH_DEVICE and count:
+                sleep(0.5)
+                mountProcess.close()
+                return self._mountToDirectory(file,directory,mountopts,count-1)
             try:
                 self._removeDirectory(directory)
             except:
@@ -722,6 +728,7 @@ class PartitionDistributive(Distributive):
                         'ext4':'/sbin/mkfs.ext4 %s %s',
                         'jfs':'/sbin/mkfs.jfs %s -f %s',
                         'reiserfs':'/sbin/mkfs.reiserfs %s -f %s',
+                        'btrfs':'/sbin/mkfs.btrfs %s %s',
                         'xfs':'/sbin/mkfs.xfs %s -f %s',
                         'vfat':'/usr/sbin/mkfs.vfat %s -F 32 %s',
                         'ntfs-3g':'/usr/sbin/mkfs.ntfs %s -FQ %s',
@@ -731,6 +738,7 @@ class PartitionDistributive(Distributive):
     labelForUtilities = { 'ext2':'-L %s',
                         'ext3':'-L %s',
                         'ext4':'-L %s',
+                        'btrfs':'-L %s',
                         'jfs':'-L %s',
                         'reiserfs':'-l %s',
                         'xfs':'-L %s',
@@ -743,6 +751,7 @@ class PartitionDistributive(Distributive):
                  'ext3' : '83',
                  'ext4' : '83',
                  'reiserfs' : '83',
+                 'btrfs' : '83',
                  'jfs' : '83',
                  'xfs' : '83',
                  'vfat' : '0b',
@@ -753,6 +762,7 @@ class PartitionDistributive(Distributive):
                     'ext3' : '0700',
                     'ext4' : '0700',
                     'reiserfs' : '0700',
+                    'btrfs' : '0700',
                     'jfs' : '0700',
                     'xfs' : '0700',
                     'vfat' : '0700',
@@ -969,13 +979,19 @@ class PartitionDistributive(Distributive):
             pipe = Popen([gdiskProg,deviceName],
                     stdin=PIPE, stdout=PIPE,stderr=PIPE)
             if devicePartitionCount > 1:
-                pipe.stdin.write("t\n%s\n%s\nw\ny\n"%(devicePartitionCount,
+                pipe.stdin.write("t\n%s\n%s\nw\ny\n"%(partitionNumber,
                                                       systemid))
             else:
                 pipe.stdin.write("t\n%s\nw\ny\n"%systemid)
             pipe.stdin.close()
             pipe.wait()
-        return True
+        for waittime in (0.1,0.2,0.5,1,2,4):
+            if path.exists(dev):
+                return True
+            else:
+                sleep(waittime)
+        raise DistributiveError(
+            _("Can not found partition %s after change system id")%dev)
 
     def formatSwapPartition(self, dev):
         """Format swap partition"""
diff --git pym/cl_fill_install.py pym/cl_fill_install.py
index fdefcbf..10d8e5d 100644
--- pym/cl_fill_install.py
+++ pym/cl_fill_install.py
@@ -28,7 +28,8 @@ from cl_utils import isMount,typeFile,getTupleVersion,pathJoin,isFstabMount,\
                      isPkgInstalled, process, checkUtils, readLinesFile, \
                      FStab, lspci, getInstalledVideo,getDeviceType, \
                      getPartitionType, getOsProberHash, getProgPath, \
-                     getRaidPartitions, getLvmPartitions, getLvmGroups
+                     getRaidPartitions, getLvmPartitions, getLvmGroups, \
+                     refreshLVM, refreshUdev
 from cl_distr import DistributiveRepository,PartitionDistributive
 from cl_fill import clLocale
 from operator import itemgetter
@@ -229,11 +230,29 @@ class fillVars(object, glob_attr):
         return ", ".join(map(lambda x:"%s (%s)"%(x[0],x[1]),
                              listInterfacesInfo))
 
+    
+    def getTableByChild(self,device):
+        """Get table by child partitions"""
+        syspath = getUdevDeviceInfo(name=device).get('DEVPATH','')
+        if not syspath.startswith('/sys'):
+            syspath = pathJoin('/sys',syspath)
+        shortnameDevice = path.basename(device)
+        childs = filter(lambda x:x.startswith(shortnameDevice),
+                 listDirectory(syspath))
+        if childs:
+            child = pathJoin(syspath,childs[0])
+            return getUdevDeviceInfo(path=child).get('ID_PART_ENTRY_SCHEME','')
+        return ""
+                 
     def get_os_device_hash(self):
+        """Generate hash information about device"""
         def onlyDisk(devpath):
+            """Check by udevadm that devpath is device (disk)"""
             prop = getUdevDeviceInfo(devpath)
             return prop.get("ID_TYPE","")=="disk" and \
                    prop.get("DEVTYPE","")=="disk"
+
+        # get usb device by '/dev/disk/by-id' (usb devices contain 'usb' in name)
         diskIdPath = '/dev/disk/by-id'
         if path.exists(diskIdPath):
             usbdevices = \
@@ -241,30 +260,39 @@ class fillVars(object, glob_attr):
              filter(lambda x: x.startswith('usb-'),listDirectory(diskIdPath)))
         else:
             usbdevices = []
+        # get devices from /sys/block directories (discard mem,sr,loop and other)
         sysBlockPath = '/sys/block'
         devices = map(lambda x:path.join(sysBlockPath,x),
                   filter(lambda x: onlyDisk(path.join(sysBlockPath,x)),
                   filter(lambda x: not self.reWrongDevice.search(x),
                   listDirectory(sysBlockPath))))
         device_hash = {}
+        # filling hash
         for mapnum,device in enumerate(sorted(devices,key=self.separateDevice)):
+            # get information by udev
             props = getUdevDeviceInfo(device)
             if not "DEVNAME" in props:
                 continue
+            # DEVNAME - /dev/(device_name)
             device = props['DEVNAME']
             device_hash[device] = {}
-            device_hash[device]['table'] = props.get('ID_PART_TABLE_TYPE','')
+            # get partition table (if PART_TABLE_TYPE absent then get by child partition)
+            device_hash[device]['table'] = props.get('ID_PART_TABLE_TYPE',
+                                           self.getTableByChild(device))
+            # enumerate disk for legecy grub
             device_hash[device]['map'] = mapnum
-            
+            # if device is usb device
             if path.basename(device) in usbdevices:
+                # check for usb flash (removeable fiel in sysfs contains "1")
                 removablePath = '/sys/block/%s/removable'%path.basename(device)
                 if os.access(removablePath,R_OK) and \
                     open(removablePath,'r').read().strip() == "1":
-                    devtype = "flash"
+                    devtype = "flash" 
                 else:
-                    devtype = "usb-hdd"
+                    devtype = "usb-hdd" 
             else:
-                devtype = "hdd"
+                devtype = "hdd" 
+            # set detect device type (hdd,flash or usb-hdd)
             device_hash[device]['type'] = devtype
         return device_hash
 
@@ -273,9 +301,11 @@ class fillVars(object, glob_attr):
         def selfOrPartition(devpath):
             """Return self device or partitions if it has them"""
             # search partition in device
+            # get devices in sysfs which startswith devname
             partitions = \
                 filter(lambda x:x.startswith(path.basename(devpath)),
                 listDirectory(devpath))
+            # if partition found then return them or partition on them
             if partitions:
                 return filter(lambda x:x,
                        map(lambda x:selfOrPartition(path.join(devpath,x)),
@@ -283,17 +313,14 @@ class fillVars(object, glob_attr):
             else:
                 return devpath
 
-        # refresh LVM
-        vgscan = getProgPath('/sbin/vgscan')
-        vgchange = getProgPath('/sbin/vgchange')
-        lvchange = getProgPath('/sbin/lvchange')
-        if vgscan and vgchange and lvchange:
-            process(vgscan).success()
-            process(vgchange,'-ay','--refresh').success()
-            for group in getLvmGroups():
-                process(lvchange,'-ay','--refresh',group).success()
+        # refresh information about LVM
+        refreshLVM()
+        # refresh information about device in udevadm info
+        refreshUdev()
+
         devicesHash = self.Get('os_device_hash')
         sysBlockPath = '/sys/block'
+        # get disks from sys block which not contains partitions
         new_disks = reduce(lambda x,y:x+ ([y] if type(y) == str else y),
                     map(lambda x:selfOrPartition(path.join(sysBlockPath,x)),
                     filter(lambda x: not self.reWrongDevice.search(x),
@@ -303,6 +330,11 @@ class fillVars(object, glob_attr):
         fstab = FStab('/etc/fstab')
         raidUsedDisks = []
         lvmUsedDisks = []
+        mapTypeUUID = {'ebd0a0a2-b9e5-4433-87c0-68b6b72699c7':'0700',
+                       '0657fd6d-a4ab-43c4-84e5-0933c84b4f4f':'8200',
+                       'a19d880f-05fc-4d3b-a006-743f0f84911e':'FD00',
+                       '21686148-6449-6e6f-744e-656564454649':'EF02'}
+        # filling information about disks
         for disk in new_disks:
             props = getUdevDeviceInfo(disk)
             if not "DEVNAME" in props:
@@ -315,12 +347,17 @@ class fillVars(object, glob_attr):
                                  props.get('ID_FS_TYPE','')
             dev_hash['name'] = props.get('ID_FS_LABEL','')
             dev_hash['table'] = props.get('ID_PART_ENTRY_SCHEME','')
+            # schema device (disk-partition or disk-partition-raid and etc)
             dev_hash['type'] = getDeviceType(disk)
-            dev_hash['id'] =props.get('ID_PART_ENTRY_TYPE','').partition("x")[2]
+            dev_hash['id'] = props.get('ID_PART_ENTRY_TYPE','').rpartition("x")[2]
+            dev_hash['id'] = mapTypeUUID.get(dev_hash['id'],dev_hash['id'])
             devParent = getPartitionDevice(disk)
             dev_hash['parent'] = devParent
+            # primary, extended or logical
             dev_hash['part'] = getPartitionType(props)
+            # get options from fstab
             dev_hash['options'] = fstab.getBy(what=fstab.OPTS,eq=devName) or ""
+            # get disk size
             dev_hash['size'] = getPartitionSize(disk)
             if devParent in devicesHash and 'ID_PART_ENTRY_NUMBER' in props:
                 dev_hash['grub'] = "%s,%d"%(devicesHash[devParent]['map'],
@@ -328,17 +365,21 @@ class fillVars(object, glob_attr):
             else:
                 dev_hash['grub'] = ""
             disk_hash[devName] = dev_hash
+            # if device raid then get its partition and add to raid partitions list
             if "raid" in dev_hash['type']:
                 raidUsedDisks.extend(map(lambda x:(devName,x),getRaidPartitions(disk)))
+            # if device lvm then get its partition and add to lvm partitions list
             if dev_hash['type'].endswith("lvm"):
                 prop = getUdevDeviceInfo(path=disk)
                 lvmUsedDisks.extend(map(lambda x:(devName,x),
                                     getLvmPartitions(prop.get('DM_VG_NAME',''),
                                                      prop.get('DM_LV_NAME',''))))
+        # fix type information for raid disks
         for disk,part in raidUsedDisks:
             if part in disk_hash:
                 disk_hash[part]['type'] = "%s-raidmember(%s)"%(
                                           disk_hash[part]['type'],disk)
+        # fix type information for lvm disks
         for disk,part in lvmUsedDisks:
             if part in disk_hash:
                 disk_hash[part]['type'] = "%s-lvmmember(%s)"%(
@@ -736,9 +777,10 @@ class fillVars(object, glob_attr):
                 livedistr = ['/mnt/cdrom']
         else:
             livedistr = []
+        rootDev = self.Get('os_install_root_dev')
         livedistr += \
             map(lambda x:x[0],
-            filter(lambda x:" live" in x[1],
+            filter(lambda x:" live" in x[1] and x[0] != rootDev,
             zip(self.Get('os_disk_dev'),
                 self.Get('os_disk_content'))))
         return ['/var/calculate/remote/linux',
diff --git pym/cl_install.py pym/cl_install.py
index 29865e1..5d9b6b3 100644
--- pym/cl_install.py
+++ pym/cl_install.py
@@ -97,7 +97,7 @@ class DataVarsInstall(DataVars):
 class convertDictOpt:
     """Convert dict install option"""
 
-    _defaultFS = "reiserfs"
+    _defaultFS = "ext4"
     _defaultFlashFS = "vfat"
 
     _diskDefaultMountPoints = { "default":{"fileSystem":_defaultFS,
@@ -301,6 +301,10 @@ class convertDictOpt:
                                       "incompatible":["uni_xlate"]}},
                               "incompatible":[],
                               "makefs":"/usr/sbin/mkfs.vfat"},
+                      "btrfs":{"options":[],
+                              "pair":{},
+                              "incompatible":[],
+                              "makefs":"/sbin/mkfs.btrfs"},
                       "ntfs":{"options":["uni_xlate","posix","nls",
                                          "utf8","iocharset",
                                          "uid","gid","umask"],
@@ -642,7 +646,9 @@ class convertDictOpt:
             availableFS = self.getAllAvailableFileSystemOpt()
             # if fs not specified and current fs not supported
             if not optFileSystem:
-                if not (format and format in set(supportedFS)-excludeFS):
+                if not (format and format in \
+                    set(availableFS)&set(supportedFS)-excludeFS) \
+                    and optMountPoint == '/':
                     optFileSystem = "default"
                 else:
                     dictUpdateProperty["fileSystem"] = format
@@ -1613,12 +1619,22 @@ class cl_install(color_print, SignalInterrupt):
                             where="os_install_disk_mount", eq="/boot")
         rootDiskType = self.varSelect("os_disk_type",
                             where="os_install_disk_mount", eq="/")
+        bootDiskFormat = self.varSelect("os_install_disk_format",
+                            where="os_install_disk_mount", eq="/boot")
+        rootDiskFormat = self.varSelect("os_install_disk_format",
+                            where="os_install_disk_mount", eq="/")
         bootDiskType = bootDiskType or rootDiskType
+        bootDiskFormat = bootDiskFormat or rootDiskFormat
         if "lvm" in bootDiskType or "raid" in bootDiskType:
             self.printERROR(
               _("Legacy grub not support boot from raid or lvm without"
                 " separate /boot partition"))
             return False
+        if bootDiskFormat == "btrfs":
+            self.printERROR(
+              _("Legacy grub not support boot from btrfs without"
+                " separate /boot partition"))
+            return False
         return True
 
     def setUsers(self,listUsers):
@@ -2613,8 +2629,12 @@ the system") + " (yes/no)"
             "march" in imageData:
             self.clVars.Set('os_install_arch_machine',
                             imageData['march'],True)
+            self.clVars.Set('os_install_linux_build',
+                            imageData['build'],True)
+            self.clVars.Set('os_install_linux_ver',
+                            imageData['ver'],True)
             self.setLinuxName(imageData['name'].upper())
-            self.clVars.Set('cl_image',True)
+            self.clVars.Set('cl_image',isoimage,True)
             return True
         else:
             self.printERROR(_("Wrong image file"))
