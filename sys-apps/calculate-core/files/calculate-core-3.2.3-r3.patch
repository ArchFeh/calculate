diff --git bin/cl-core bin/cl-core
index 0509fdd..c923e34 100644
--- bin/cl-core
+++ bin/cl-core
@@ -15,17 +15,13 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
-from calculate.core.server.wsdl_meta import WsdlMeta
 from calculate.core.server.cl_server import main
-
-import sys
+import sys, os
 reload(sys)
+from calculate.lib.datavars import CriticalError
 sys.setdefaultencoding("utf-8")
-
 from calculate.lib.cl_lang import setLocalTranslate
-from calculate.lib.datavars import CriticalError
-
-setLocalTranslate('cl_core', sys.modules[__name__])
+setLocalTranslate('cl_core',sys.modules[__name__])
 from traceback import print_exc
 
 if __name__=='__main__':
@@ -46,5 +42,3 @@ if __name__=='__main__':
                 e.message.rpartition(no_module)[2]
         else:
             print e.message
-    finally:
-        WsdlMeta.close_datavars()
diff --git pym/core/result_viewer.py pym/core/result_viewer.py
new file mode 100644
index 0000000..2929f2b
--- /dev/null
+++ pym/core/result_viewer.py
@@ -0,0 +1,667 @@
+#-*- coding: utf-8 -*-
+
+# Copyright 2011-2013 Calculate Ltd. http://www.calculate-linux.org
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+from itertools import cycle
+from calculate.lib.utils.colortext import get_terminal_print, Terminal, \
+    TextState, convert_xml_to_terminal, Print
+from calculate.lib.cl_progressbar import get_progress_bar
+import sys
+from calculate.lib.utils.files import getch, set_active_tty
+from calculate.lib.utils.text import tableReport
+import threading
+from calculate.lib.utils.tools import classificate
+
+Colors = TextState.Colors
+from calculate.lib.cl_lang import setLocalTranslate
+setLocalTranslate('cl_core3', sys.modules[__name__])
+
+
+class Spinner(threading.Thread):
+    def __init__(self, *args, **kwargs):
+        self.__halt = threading.Event()
+        self.__main_thread = threading.currentThread()
+        threading.Thread.__init__(self, *args, **kwargs)
+        self.start()
+
+    def run(self):
+        Terminal().cursor = False
+        try:
+            sys.stdout.write(" |")
+            for c in cycle('/-\|'):
+                sys.stdout.write('\b' + c)
+                sys.stdout.flush()
+                self.__halt.wait(0.2)
+                sys.stdout.flush()
+                if self.__halt.is_set():
+                    sys.stdout.write('\b\b  \b\b')
+                    return
+                if not self.__main_thread.is_alive():
+                    return
+        finally:
+            Terminal().cursor = True
+
+    def stop(self):
+        self.__halt.set()
+        self.join()
+
+
+class Table(tableReport):
+    def __init__(self, *args, **kwargs):
+        self.res = []
+        tableReport.__init__(self, *args, **kwargs)
+
+    def printFunc(self, s):
+        self.res.append(s)
+
+    def printTable(self):
+        self.setAutosize()
+        self.printReport(printRows=False)
+        return "".join(self.res)
+
+
+def printTable(data, header=None):
+    try:
+        return Table(None, header, data, colSpan=0).printTable()
+    except Exception as e:
+        print str(e)
+        raise
+
+
+class TaskState(object):
+    """
+    Текущее состояние вывода сообщений
+    """
+    def __init__(self, parent):
+        """
+        @type parent: ResultViewer
+        """
+        self.parent = parent
+
+    @property
+    def state(self):
+        return self.parent.task_state
+
+    def echo_on(f):
+        def wrapper(self, *args, **kw):
+            oldecho = self.parent.terminal_info.echo
+            self.parent.terminal_info.echo = True
+            try:
+                return f(self, *args, **kw)
+            finally:
+                self.parent.terminal_info.echo = oldecho
+        return wrapper
+
+    def process_tags(self, s):
+        """
+        Выполнить текстовое преобразование
+        """
+        s = s or ""
+        return convert_xml_to_terminal(s).replace("&nbsp;", " ")
+
+    def display_asterisk(self, color):
+        """
+        Отобразить маркер
+        """
+        self.parent.printer(" ")
+        self.parent.printer.foreground(color).bold("*")
+        self.parent.printer(" ")
+
+    def _right_indent(self, indent, width=-1):
+        """
+        Выполнить выравнивание от правого края
+        """
+        if width > 0:
+            self.parent.printer('\r')
+            self.parent.printer.right(width-indent)
+        else:
+            self.parent.printer(" ")
+
+    def _change_asterisk(self, color, width=-1):
+        if width > 0:
+            self.parent.printer('\r')
+            self.display_asterisk(color)
+
+    def dotting(self):
+        if self.parent.spinner:
+            self.parent.spinner.stop()
+        self.parent.printer(" ...")
+        self.parent.printer.flush()
+
+    def _print_result(self, text, color):
+        width = self.parent.terminal_info.width
+        self._change_asterisk(color, width)
+        self._right_indent(len(text)+4, width)
+        self.parent.printer.bold.foreground(TextState.Colors.BLUE)("[ ")
+        self.parent.printer.bold.foreground(color)(text)
+        self.parent.printer.bold.foreground(TextState.Colors.BLUE)(" ]")
+        self.parent.printer("\n")
+
+    def _print_ok(self):
+        self._print_result("ok", TextState.Colors.GREEN)
+
+    def _print_failed(self):
+        self._print_result("!!", TextState.Colors.RED)
+
+    def _print_skip(self):
+        self._print_result("skip", TextState.Colors.YELLOW)
+
+    def display_result(self, result):
+        func_map = {"skip": self._print_skip,
+                    False: self._print_failed}
+        func_map.get(result, self._print_ok)()
+        self.parent.printer.flush()
+
+    def startTask(self, message, progress, num):
+        pass
+
+    def endTask(self, result, progress_message=None):
+        pass
+
+    def breakTask(self):
+        pass
+
+    def printMessage(self, color, message):
+        for i, line in classificate(self.process_tags(message).split('\n')):
+            self.display_asterisk(color)
+            self.parent.printer(line)
+            if not i.last:
+                self.parent.printer('\n')
+        self.parent.printer.flush()
+
+    def printERROR(self, message):
+        self.printMessage(Colors.RED, message)
+
+    def printSUCCESS(self, message):
+        self.printMessage(Colors.GREEN, message)
+
+    def printWARNING(self, message):
+        self.printMessage(Colors.YELLOW, message)
+
+    def startGroup(self, message):
+        self.parent.printer.foreground(Colors.WHITE)(self.process_tags(message))
+        self.parent.printer('\n')
+
+    def endGroup(self):
+        pass
+
+    def beginFrame(self, message):
+        self.parent.terminal_info.echo = False
+
+    def endFrame(self):
+        self.parent.terminal_info.echo = True
+
+    def addProgress(self, message):
+        pass
+
+    def setProgress(self, percent, short_message, long_message):
+        pass
+
+    @echo_on
+    def askConfirm(self, message, default):
+        self.parent.printer("\n")
+        while True:
+            try:
+                _print = Print(output=self.parent.printer.output)
+                if default in "yes":
+                    yes_color, no_color = Colors.GREEN, Colors.LIGHT_RED
+                else:
+                    yes_color, no_color = Colors.LIGHT_RED, Colors.GREEN
+                yes = _print.foreground(yes_color)("Yes")
+                no = _print.foreground(no_color)("No")
+                white_message = _print.foreground(Colors.WHITE)(message)
+                ask = raw_input(white_message + ' (%s/%s): ' % (yes, no))
+            except (EOFError,KeyboardInterrupt):
+                ask = 'no'
+                print
+            if ask.lower() in ['n', 'no']:
+                return "no"
+            if ask.lower() in ['y', 'yes']:
+                return "yes"
+            if ask == '':
+                return default
+
+    def printPre(self, message):
+        self.parent.printer(self.process_tags(message))
+        self.parent.printer('\n')
+
+    def printDefault(self, message):
+        self.parent.printer(self.process_tags(message))
+        self.parent.printer('\n')
+
+    @echo_on
+    def askChoice(self, message, answers):
+        self.parent.printer("\n")
+        Colors = TextState.Colors
+        printer = self.parent.printer
+        _print = Print(output=printer.output)
+        # ability answer by first letter
+        FIRSTLETTER = 0
+        VALUE, COMMENT = 0, 1
+        answerByChar = map(lambda x: x[VALUE][FIRSTLETTER], answers)
+
+        if filter(lambda x: answerByChar.count(x) > 1, answerByChar):
+            use_getch = False
+            sa = slice(None)
+        else:
+            use_getch = True
+            sa = slice(1)
+        message = _print.foreground(Colors.WHITE)(message)
+        full_message = message + ' (%s): ' % \
+                       ("/".join(map(lambda x: \
+                                         "%s[%s]" % (x[COMMENT], x[VALUE][sa]),
+                                     answers)))
+        while True:
+            CTRC_C = chr(3)
+            if use_getch:
+                printer(full_message)
+                ask = getch()
+                printer("\n")
+                if ask in (CTRC_C,""):
+                    raise KeyboardInterrupt
+            else:
+                try:
+                    ask = raw_input(full_message)
+                except (EOFError,KeyboardInterrupt):
+                    printer("\n")
+                    raise KeyboardInterrupt
+            ask = ask.lower()
+            like_answers = filter(lambda x: x[VALUE].startswith(ask),
+                                  answers)
+            if not like_answers:
+                self.state.printERROR(_('The answer is uncertain'))
+                continue
+            if len(like_answers) == 1:
+                return like_answers[VALUE][FIRSTLETTER]
+            else:
+                self.state.printERROR(_('Ambiguous answer:') +
+                                       ",".join(map(lambda x: x[COMMENT],
+                                                    like_answers)))
+
+    @echo_on
+    def askQuestion(self, message):
+        self.parent.printer("\n")
+        return raw_input(message + _(":"))
+
+    def askPassword(self, message, twice):
+        from calculate.lib.utils.common import getpass
+        if self.parent.terminal_info.is_boot_console():
+            set_active_tty(1)
+
+        text1 = _("%s: ") % message
+        if not twice:
+            return getpass.getpass(text1)
+        text2 = _('Repeat: ')
+        pass1 = 'password'
+        pass2 = 'repeat'
+        try:
+            while pass1 != pass2:
+                pass1 = getpass.getpass(text1)
+                pass2 = getpass.getpass(text2)
+                if pass1 != pass2:
+                    self.state.printERROR(_('Passwords do not match'))
+        except KeyboardInterrupt:
+            return None
+        passwd = pass1 if (pass1 and pass1 == pass2) else None
+        return passwd
+
+    def printTable(self, table_name, head, body):
+        self.state.printSUCCESS(message=table_name)
+        self.parent.printer(printTable(body, head))
+
+
+class CleanState(TaskState):
+    """
+    Ожидается вывод
+    """
+    def startTask(self, message, progress, num):
+        self.printMessage(Colors.GREEN, message)
+        self.parent.spinner = Spinner()
+        self.parent.set_state('start')
+        if progress:
+            self.parent.addProgress()
+
+    def printERROR(self, message):
+        super(CleanState, self).printERROR(message)
+        self.parent.printer('\n')
+
+    def printSUCCESS(self, message):
+        super(CleanState, self).printSUCCESS(message)
+        self.parent.printer('\n')
+
+    def printWARNING(self, message):
+        super(CleanState, self).printWARNING(message)
+        self.parent.printer('\n')
+
+
+class CleanStateNoProgress(CleanState):
+    """
+    ... без отображения прогрессов
+    """
+    def startTask(self, message, progress, num):
+        self.display_asterisk(Colors.GREEN)
+        self.parent.printer(message)
+        self.dotting()
+        self.parent.set_state('start')
+
+
+class StartState(TaskState):
+    """
+    Выполняется задача (отображается spinner)
+    """
+    def startTask(self, message, progress, num):
+        self.parent.endTask(True)
+        self.parent.startTask(message, progress, num)
+
+    def endTask(self, result, progress_message=None):
+        self.dotting()
+        self.parent.set_state('clean')
+        self.display_result(result)
+
+    def breakTask(self):
+        self.dotting()
+        self.parent.set_state('clean')
+        self.parent.printer('\n')
+
+    def printERROR(self, message):
+        self.dotting()
+        self.parent.printer('\n')
+        self.parent.set_state('clean')
+        self.state.printERROR(message)
+
+    def printSUCCESS(self, message):
+        self.dotting()
+        self.parent.set_state('breaked')
+        self.state.printSUCCESS(message)
+
+    def printWARNING(self, message):
+        self.dotting()
+        self.parent.set_state('breaked')
+        self.state.printWARNING(message)
+
+    def startGroup(self, message):
+        self.state.endTask(True)
+        self.state.startGroup(message)
+
+    def endGroup(self):
+        self.state.endTask(True)
+        self.state.endGroup()
+
+    def beginFrame(self, message):
+        self.state.endTask(True)
+        self.state.beginFrame(message)
+
+    def endFrame(self):
+        self.state.endTask(True)
+        self.state.endFrame()
+
+    def addProgress(self, message):
+        self.parent.set_state("pre-progress")
+        self.state.addProgress(message)
+
+    def printPre(self, message):
+        self.parent.endTask(True)
+        self.state.printPre(message)
+
+    def printDefault(self, message):
+        self.state.endTask(True)
+        self.state.printDefault(message)
+
+    def askChoice(self, message, answers):
+        self.breakTask()
+        return self.state.askChoice(message, answers)
+
+    def askQuestion(self, message):
+        self.breakTask()
+        return self.state.askQuestion(message)
+
+    def askPassword(self, message, twice):
+        self.breakTask()
+        return self.state.askPassword(message, twice)
+
+    def askConfirm(self, message, default):
+        self.breakTask()
+        return self.state.askConfirm(message, default)
+
+    def printTable(self, table_name, head, body):
+        self.breakTask()
+        self.state.printTable(table_name, head, body)
+
+
+class StartStateNoProgress(StartState):
+    """
+    ... без прогресса
+    """
+    def startTask(self, message, progress, num):
+        self.parent.endTask(True)
+        self.parent.startTask(message, progress, num)
+
+    def endTask(self, result, progress_message=None):
+        self.parent.set_state('clean')
+        self.display_result(result)
+
+    def breakTask(self):
+        self.parent.printer('\n')
+
+    def printERROR(self, message):
+        self.breakTask()
+        self.parent.set_state('clean')
+        self.state.printERROR(message)
+
+    def printSUCCESS(self, message):
+        self.breakTask()
+        self.parent.set_state('clean')
+        self.state.printSUCCESS(message)
+
+    def printWARNING(self, message):
+        self.breakTask()
+        self.parent.set_state('clean')
+        self.state.printWARNING(message)
+
+    def addProgress(self, message):
+        pass
+
+
+class BreakedState(StartState):
+    """
+    Во время выполнения задачи выведено сообщение
+    """
+    def stop_spinner_newline(self):
+        self.parent.spinner.stop()
+        self.parent.printer('\n')
+
+    def startTask(self, message, progress, num):
+        self.state.endTask(True)
+        self.state.startTask(message, progress, num)
+
+    def breakTask(self):
+        self.stop_spinner_newline()
+        self.parent.set_state('clean')
+
+    def endTask(self, result, progress_message=None):
+        self.breakTask()
+
+    def printERROR(self, message):
+        self.parent.endTask(True)
+        self.state.printERROR(message)
+
+    def printSUCCESS(self, message):
+        self.stop_spinner_newline()
+        TaskState.printSUCCESS(self, message)
+        self.parent.spinner = Spinner()
+
+    def printWARNING(self, message):
+        self.stop_spinner_newline()
+        TaskState.printWARNING(self, message)
+        self.parent.spinner = Spinner()
+
+
+class PreProgressState(StartState):
+    """
+    Задача запрошена как с прогрессом но проценты еще не обрабатывались
+    """
+    def addProgress(self, message):
+        pass
+
+    def setProgress(self, percent, short_message, long_message):
+        self.parent.set_state("progress")
+        self.dotting()
+        self.parent.printer("\n")
+        self.parent.add_progressbar()
+        self.parent.terminal_info.cursor = False
+        self.state.setProgress(percent, short_message, long_message)
+
+
+class ProgressState(StartState):
+    """
+    Отображается progressbar
+    """
+    def finish_and_clean(self):
+        self.parent.printer('\r')
+        self.parent.printer.flush()
+        self.parent.progress.finish()
+        self.parent.terminal_info.cursor = True
+        self.parent.set_progressbar(None)
+        self.parent.printer.up(1).clear_line("")
+        self.parent.printer.up(1)("")
+
+    def setProgress(self, percent, short_message, long_message):
+        if 0 < percent > 100:
+            self.breakTask()
+        else:
+            self.parent.progress.update(percent)
+
+    def breakTask(self):
+        self.finish_and_clean()
+        self.parent.set_state('clean')
+        self.parent.printer('\n')
+
+    def endTask(self, result, progress_message=None):
+        self.finish_and_clean()
+        self.parent.set_state('clean')
+        self.display_result(result)
+
+    def printERROR(self, message):
+        self.finish_and_clean()
+        self.parent.printer.down(1)("")
+        self.parent.set_state('clean')
+        self.state.printERROR(message)
+
+    def printSUCCESS(self, message):
+        self.finish_and_clean()
+        self.parent.set_state('breaked')
+        self.state.printSUCCESS(message)
+
+    def printWARNING(self, message):
+        self.finish_and_clean()
+        self.parent.set_state('breaked')
+        self.state.printWARNING(message)
+
+
+class ResultViewer(object):
+    """
+    Просмотрщик результатов
+    """
+    def __init__(self):
+        self.printer = \
+            get_terminal_print(sys.stdout)
+        self.terminal_info = Terminal()
+        self.states = {'clean': CleanState(self),
+                       'breaked': BreakedState(self),
+                       'pre-progress': PreProgressState(self),
+                       'progress': ProgressState(self),
+                       'start': StartState(self)}
+        self.task_state = self.states['clean']
+        self.spinner = None
+        self.progress = None
+        self.no_questions = False
+
+    def set_no_progress(self):
+        self.states = {'clean': CleanStateNoProgress(self),
+                       'start': StartStateNoProgress(self)}
+        self.set_state('clean')
+
+    def set_no_questions(self):
+        self.no_questions = True
+
+    def set_state(self, state):
+        self.task_state = self.states[state]
+
+    def add_progressbar(self):
+        self.set_progressbar(get_progress_bar())
+
+    def set_progressbar(self, pb):
+        self.progress = pb
+
+    def endTask(self, result=None, progress_message=None):
+        self.task_state.endTask(result, progress_message)
+
+    def startTask(self, message, progress=False, num=1):
+        self.task_state.startTask(message, progress, num)
+
+    def printERROR(self, message, onlyShow=None):
+        if onlyShow != 'gui':
+            self.task_state.printERROR(message)
+
+    def printSUCCESS(self, message, onlyShow=None):
+        if onlyShow != 'gui':
+            self.task_state.printSUCCESS(message)
+
+    def printWARNING(self, message, onlyShow=None):
+        if onlyShow != 'gui':
+            self.task_state.printWARNING(message)
+
+    def startGroup(self, message):
+        self.task_state.startGroup(message)
+
+    def endGroup(self):
+        self.task_state.endGroup()
+
+    def beginFrame(self, message=None):
+        self.task_state.beginFrame(message)
+
+    def endFrame(self):
+        self.task_state.endFrame()
+
+    def addProgress(self, message=None):
+        self.task_state.addProgress(message)
+
+    def setProgress(self, percent, short_message=None, long_message=None):
+        self.task_state.setProgress(percent, short_message, long_message)
+
+    def printPre(self, message, onlyShow=None):
+        if onlyShow != 'gui':
+            self.task_state.printPre(message)
+
+    def printDefault(self, message='', onlyShow=None):
+        if onlyShow != 'gui':
+            self.task_state.printDefault(message)
+
+    def askConfirm(self, message, default="yes"):
+        if self.no_questions:
+            return default
+        return self.task_state.askConfirm(message, default)
+
+    def askChoice(self, message, answers=(("yes", "Yes"), ("no", "No"))):
+        return self.task_state.askChoice(message, answers)
+
+    def askPassword(self, message, twice=False):
+        return self.task_state.askPassword(message, twice)
+
+    def askQuestion(self, message):
+        return self.task_state.askQuestion(message)
+
+    def printTable(self, table_name, head, body, fields=None,
+                   onClick=None, addAction=None):
+        self.task_state.printTable(table_name, head, body)
diff --git pym/core/result_viewer_gui.py pym/core/result_viewer_gui.py
new file mode 100644
index 0000000..1918496
--- /dev/null
+++ pym/core/result_viewer_gui.py
@@ -0,0 +1,120 @@
+#-*- coding: utf-8 -*-
+
+# Copyright 2011-2013 Calculate Ltd. http://www.calculate-linux.org
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+from calculate.lib.cl_progressbar import get_progress_bar, get_message_box
+from calculate.lib.utils.colortext import TextState
+import sys
+from result_viewer import PreProgressState, ProgressState
+
+Colors = TextState.Colors
+from calculate.lib.cl_lang import setLocalTranslate
+setLocalTranslate('cl_core3', sys.modules[__name__])
+
+
+class PreProgressStateGui(PreProgressState):
+    """
+    Задача запрошена как с прогрессом но проценты еще не обрабатывались
+    """
+    def addProgress(self, message):
+        self.dotting()
+        self.parent.printer("\n")
+        self.parent.add_progressbar()
+        self.parent.set_state("progress")
+
+
+class ProgressStateGui(ProgressState):
+    """
+    Отображение для gui прогресса
+    """
+    def finish_and_clean(self):
+        self.parent.progress.finish()
+        self.parent.printer.up(1)("")
+        self.parent.set_progressbar(None)
+
+class ResultViewerDecorator(object):
+    def __init__(self, rv):
+        self.rv = rv
+        for v in self.rv.states.values():
+            v.parent = self
+
+    def __getattr__(self, item):
+        return getattr(self.rv, item)
+
+
+class ProgressGui(ResultViewerDecorator):
+    """
+    Отображение прогресса в Qt диалогах
+    """
+    def __init__(self, rv):
+        super(ProgressGui, self).__init__(rv)
+        self.rv.states['pre-progress'] = PreProgressStateGui(self)
+        self.rv.states['progress'] = ProgressStateGui(self)
+        self.progress_title = ""
+
+    def add_progressbar(self):
+        self.set_progressbar(get_progress_bar("gui", self.progress_title))
+
+    def startTask(self, message, progress=False, num=1):
+        self.rv.startTask(message, progress, num)
+        self.progress_title = message
+
+
+class ErrorGui(ResultViewerDecorator):
+    """
+    Отображение ошибок через gui
+    """
+    def __init__(self, rv):
+        super(ErrorGui, self).__init__(rv)
+        self.messages = []
+
+    def show_messages(self):
+        get_message_box().critical("\n".join(self.messages).decode('utf-8'))
+
+    def printERROR(self, message, onlyShow=None):
+        self.rv.printERROR(message, onlyShow)
+        if onlyShow != 'gui':
+            if message:
+                self.messages.append(message)
+
+    def endFrame(self):
+        self.rv.task_state.endFrame()
+        if self.messages:
+            self.show_messages()
+
+
+class WarningGui(ResultViewerDecorator):
+    """
+    Отображение предупреждений через gui
+    """
+    def __init__(self, rv):
+        super(WarningGui, self).__init__(rv)
+        self.warnings = []
+
+    def show_messages(self):
+        get_message_box().warning("\n".join(self.warnings).decode('utf-8'))
+
+    def printWARNING(self, message, onlyShow=None):
+        self.rv.printWARNING(message, onlyShow)
+        if onlyShow != 'gui':
+            if message:
+                self.warnings.append(message)
+
+    def endFrame(self):
+        self.rv.task_state.endFrame()
+        if not self.messages and self.warnings:
+            self.show_messages()
+        elif self.messages:
+            self.messages.extend(self.warnings)
+            self.rv.show_messages()
diff --git pym/core/server/action.py pym/core/server/action.py
deleted file mode 100644
index 9692f48..0000000
--- pym/core/server/action.py
+++ /dev/null
@@ -1,554 +0,0 @@
-#-*- coding: utf-8 -*-
-
-# Copyright 2014 Calculate Ltd. http://www.calculate-linux.org
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-import re
-from calculate.core.server.task_set import MessagingSupport
-from calculate.lib.cl_lang import setLocalTranslate, getLazyLocalTranslate
-from calculate.lib.cl_log import log
-from calculate.lib.datavars import CriticalError
-from calculate.lib.utils.files import getProgPath, processProgress
-from calculate.lib.utils.tools import short_traceback
-import sys
-
-_ = lambda x: x
-setLocalTranslate('cl_core3', sys.modules[__name__])
-__ = getLazyLocalTranslate(_)
-
-
-class ActionError(Exception):
-    pass
-
-
-class Tasks:
-    """
-    Класс для создания проверок необходимости запуска задачи в зависимости
-    от результатра работы предыдущих задач
-    """
-
-    def __init__(self, check):
-        self.check = check
-
-    def __call__(self, result):
-        return self.check(result)
-
-    def __or__(self, y):
-        return Tasks(lambda result: self(result) or y(result))
-
-    def __ror__(self, y):
-        return Tasks(lambda result: y(result) or self(result))
-
-    def __and__(self, y):
-        return Tasks(lambda result: self(result) and y(result))
-
-    def __rand__(self, y):
-        return Tasks(lambda result: y(result) and self(result))
-
-    def __invert__(self):
-        return Tasks(lambda result: not self(result))
-
-    @classmethod
-    def success_all(cls, *tasks):
-        """
-        Все указанные задачи выполнены и выполнены без ошибок
-        """
-        return Tasks(
-            lambda result: all(x in result and result[x] for x in tasks))
-
-    @classmethod
-    def success_one_of(cls, *tasks):
-        """
-        Хотя бы одна из задач выполнена и хотя бы одна из выполненных без ошибок
-        """
-        return Tasks(
-            lambda result: any(result[x] for x in tasks if x in result))
-
-    @classmethod
-    def success(cls, inessential=[]):
-        """
-        Все ранее запущенные задачи успешно завершены, результат задач
-        inessential не важен
-        """
-        return Tasks(lambda result: all(result[x] for x in result
-                                        if x not in inessential))
-
-    @classmethod
-    def failed(cls, inessential=[]):
-        """
-        Хотя бы одна из задач завершилась неудачно, результат задач
-        inessential не важен
-        """
-        return Tasks(lambda result: any(not result[x] for x in result
-                                        if x not in inessential))
-
-    @classmethod
-    def failed_all(cls, *tasks):
-        """
-        Выполнена хотя бы одна задача и все те, которые выполнены с ошибкой
-        """
-        return Tasks(
-            lambda result: any(not result[x] for x in tasks if x in result))
-
-    @classmethod
-    def failed_one_of(cls, *tasks):
-        """
-        Хотя бы одна из указанных задач выполнена и выполнена с ошибкой
-        """
-        return Tasks(
-            lambda result: any(x in result and not result[x] for x in tasks))
-
-    @classmethod
-    def has(cls, *tasks):
-        """
-        Был запуск всех перечисленных задач
-        """
-        return Tasks(lambda result: all(x in result for x in tasks))
-
-    @classmethod
-    def hasnot(cls, *tasks):
-        """
-        Не было запуска ни одной из перечисленных задач
-        """
-        return Tasks(lambda result: all(x not in result for x in tasks))
-
-    @classmethod
-    def result(cls, task, eq=None, ne=None):
-        if eq:
-            wrapper = lambda result: task in result and result[task] == eq
-        elif ne:
-            wrapper = lambda result: not task in result or result[task] != ne
-        else:
-            wrapper = lambda result: task in result and result[task]
-        return Tasks(wrapper)
-
-    @classmethod
-    def has_any(cls, *tasks):
-        """
-        Был запуск любой из задач
-        """
-        return Tasks(lambda result: any(x in result for x in tasks))
-
-    FailedTask = "failed"
-    SuccessTask = "success"
-    InterruptTask = "intmessage"
-
-
-class Action(MessagingSupport):
-    """
-    Класс для реализации выполнения действия
-    """
-    # список исключений, которые выводятся в сокращенном формате (ожидаемые ошибки)
-    # остальные выводятся с именем модуля и номером строки
-    native_error = ()
-
-    # сообщение об удачном завершении действия
-    successMessage = None
-    # сообщение при ошибке
-    failedMessage = None
-    # сообщение о прерывании
-    interruptMessage = None
-
-    # список задач для дейсвия
-    tasks = []
-    # добавить стандартные сообщения в конце
-    finishMessage = True
-
-    def __init__(self, messaging_api, process_api, dv, tsa, method_name=None):
-        """
-        :param messaging_api: MessagingAPI
-        :param dv:  DataVars
-        :param tsa: TaskSetAggregation
-        :return:
-        """
-        super(Action, self).__init__(messaging_api)
-        if self.finishMessage:
-            tasks = []
-            if self.failedMessage:
-                tasks.append(
-                    # вывести сообщение в случае ошибки
-                    {'name': Tasks.FailedTask,
-                     'error': self.failedMessage,
-                     'depend': (Tasks.failed() &
-                                Tasks.hasnot(Tasks.InterruptTask))})
-            if self.successMessage:
-                tasks.append(
-                    # вывести сообщение в случае успеха
-                    {'name': Tasks.SuccessTask,
-                     'message': self.successMessage,
-                     'depend': (Tasks.success() &
-                                Tasks.hasnot(Tasks.FailedTask))})
-            if self.interruptMessage:
-                tasks.append(
-                    # вывести сообщение о том, что действие прервано
-                    {'name': Tasks.InterruptTask,
-                     'error': self.interruptMessage,
-                     'depend': (Tasks.has(Tasks.InterruptTask))})
-            self.tasks = self.tasks + tasks
-        self.group_name = ""
-        self.clVars = dv
-        self.tsa = tsa
-        self.method_name = method_name
-        self.process = process_api
-
-    @classmethod
-    def program(cls, cmd_name):
-        """
-        Проверить наличие программы
-        """
-        return lambda dv: bool(getProgPath(cmd_name))
-
-    @classmethod
-    def packageInstalled(cls, pkg):
-        """
-        Проверить было ли обновление пакета
-        """
-        return lambda dv: False
-
-    @classmethod
-    def variables(cls, *varnames):
-        """
-        Передать переменные как аргументы, поддерживается True,False
-        """
-        return lambda dv: [dv.Get(x) if not x in (True, False) else x \
-                           for x in varnames]
-
-    reMethod = re.compile("^([A-Za-z]+)\.([A-Za-z0-9_]+)\(([^)]*)\)$")
-    reMessageVars = re.compile("\{([^}]+)\}")
-
-    def parseMethod(self, tsa, dv, s, task):
-        """
-        Разобрать строку метода, на объект, метод, аргументы
-        """
-        result = self.reMethod.search(s)
-        if not result:
-            raise ActionError(_("Wrong method for task %s") % task)
-        objname, methodname, args = result.groups()
-        if not objname in tsa:
-            raise ActionError(_("Object %s not found") % objname)
-        obj = tsa[objname]
-        if not hasattr(obj, methodname):
-            raise ActionError(_("Method {method} for {obj} not found").
-                              format(method=methodname, obj=objname))
-
-        def _convertMethodArg(param):
-            """
-            Конвертировать аргумент для метода, взять по словарю,
-            либо строка - имя переменной
-            """
-            param = param.strip()
-            mapStd = {'True':True,
-                      'False':False,
-                      'None':None,
-                      '""':"",
-                      "''":""}
-            if param in mapStd:
-                return mapStd[param]
-            if param.isdigit():
-                return int(param)
-            if param.startswith('"') and param.endswith('"'):
-                return param.strip('"')
-            if param == 'eachvar':
-                return self.eachvar
-            _type = dv.getInfo(param).type
-            if _type == "int":
-                return dv.GetInteger(param)
-            if _type == "bool":
-                return dv.GetBool(param)
-            return dv.Get(param)
-
-        if args:
-            args = map(_convertMethodArg, args.split(','))
-        else:
-            args = ()
-        return getattr(obj,methodname),args
-
-    def formatMessage(self,dv,message):
-        """
-        Вставить значения переменных в текст сообщения
-        """
-
-        class TextTrasformer:
-            def first_letter_upper(self, s):
-                return "%s%s" % (s[0].upper(), s[1:])
-
-        tt = TextTrasformer()
-
-        def replace_value(match):
-            var = match.group(1)
-            if ":" in var:
-                var, func = var.split(':')
-            else:
-                func = None
-            if var == "eachvar":
-                val = self.eachvar
-            else:
-                val = dv.Get(var)
-            if type(val) == list:
-                val = ",".join(val)
-            if func:
-                if hasattr(tt, func):
-                    val = getattr(tt, func)(val)
-                else:
-                    val = getattr(val, func)()
-            return "{0}".format(val)
-
-        return self.reMessageVars.sub(replace_value, str(message))
-
-    def runCondition(self, funcCondition):
-        """
-        Запустить метод проверки условия (если аргумент называется Get,
-        то передавать в него не объект DataVars а метод Get,
-        если у нет аргументов, то не передавать туда аргументы
-        """
-        args = []
-        arg_count = funcCondition.func_code.co_argcount
-        for param_name in funcCondition.func_code.co_varnames[:arg_count]:
-            if param_name in ('Get', 'Select', 'ZipVars'):
-                args.append(getattr(self.clVars, param_name))
-            elif param_name == 'eachvar':
-                args.append(self.eachvar)
-            else:
-                args.append(self.clVars)
-        return funcCondition(*args)
-
-    def getFormatMessage(self, action, *fields):
-        """
-        Получить сообщение для вывода среди нескольких с приоритетом и
-        метод вывода
-        """
-        for field in (x for x in fields if x in action):
-            if "error" in field:
-                printFunc = self.printERROR
-            elif "warning" in field:
-                printFunc = self.printWARNING
-            else:
-                printFunc = self.printSUCCESS
-            return printFunc, self.formatMessage(self.clVars, action[field])
-        return None, None
-
-    def get_tasks(self, result):
-        """
-        Герератор задач (поддержка линейной обработки задач в группах)
-        """
-        for task in self.tasks:
-            if "group" in task:
-                if all(self.get_condition_context(task, result).values()):
-                    self.group_name = task["group"]
-                    for action in task["tasks"]:
-                        yield action
-                    if not self.group_name:
-                        self.endGroup()
-                    else:
-                        self.group_name = ""
-            else:
-                yield task
-
-    def get_condition_context(self, action, result):
-        """
-        Получить результаты проверки по зависимосятм и условиям
-        """
-        group, op, name = action.get("name",
-                                     "<unknown>").rpartition(':')
-        # проверить по результатам
-        # если указанно группа к имени с '!', то проверяется
-        # только условие принадлежности задачи к группе
-        if group and group.endswith('!'):
-            group = group.strip('!')
-            depend = [Tasks.success_all(group)]
-        else:
-            depend = action.get("depend", Tasks.success())
-            depend = (depend
-                      if type(depend) in (list, tuple) else [depend])
-            if group:
-                depend.append(Tasks.success_all(group))
-        depend_result = all([x(result) for x in depend])
-        # проверить по условиям
-        if depend_result:
-            condition_funcs = action.get("condition", lambda dv: True)
-            condition_funcs = (condition_funcs
-                               if type(condition_funcs) in (list, tuple)
-                               else [condition_funcs])
-            condition_result = all(
-                [self.runCondition(x) for x in condition_funcs])
-        else:
-            condition_result = True
-        return {'condition': condition_result, 'depend': depend_result}
-
-    def run(self):
-        """Запустить список действий"""
-
-        class StubLogger:
-            def info(self, s):
-                pass
-        result = {}
-
-        self.group_name = ""
-        dv = self.clVars
-        if dv.Get('cl_env_debug_set') == 'off' or \
-                dv.Get('cl_ebuild_phase'):
-            logger = StubLogger()
-        else:
-            logger = log("core-action.log",
-                         filename="/var/log/calculate/core-action.log",
-                         formatter="%(asctime)s - %(levelname)s - %(message)s")
-        try:
-            self.beginFrame()
-            logger.info("Start {methodname}".format(
-                methodname=self.method_name))
-            for action in self.get_tasks(result):
-                foreach = action.get("foreach","")
-                if foreach:
-                    foreach = self.clVars.Get(foreach)
-                else:
-                    foreach = [""]
-                self.eachvar = ""
-                for eachvar in foreach:
-                    self.eachvar = eachvar
-                    group,op,name = action.get("name",
-                                               "<unknown>").rpartition(':')
-                    res = True
-                    task = False
-                    try:
-                        run_context = self.get_condition_context(action, result)
-                        actinfo = "Run" if all(run_context.values()) else "Skip"
-                        logger.info(
-                            "{action} {name}: condition: {condition}, "
-                            "depend: {depend}".format(
-                                action=actinfo,
-                                name=name,
-                                condition=run_context['condition'],
-                                depend=run_context['depend']))
-
-                        elsePrint, elseMessage = (
-                            self.getFormatMessage(action,"else_error",
-                                                  "else_warning","else_message"))
-                        if (run_context['depend'] and
-                                not run_context['condition'] and elseMessage):
-                            if "else_error" in action:
-                                if action.get("essential", True):
-                                    result[name]=False
-                            elsePrint(elseMessage)
-                        if all(run_context.values()):
-                            self.process.save_status()
-                            if self.group_name:
-                                self.startGroup(str(self.group_name))
-                                self.group_name = None
-                            printFunc, message = self.getFormatMessage(
-                                action,"error","warning","message")
-                            if "confirm" in action and message:
-                                result[name] = \
-                                    self.askConfirm(str(message),
-                                                    action["confirm"])
-                                continue
-                            elif message:
-                                # если действие с командой
-                                if not "error" in action and \
-                                                "method" in action or "command" in action:
-                                    self.startTask(str(message))
-                                    task = True
-                                # действие содержит только сообщение
-                                else:
-                                    if "error" in action:
-                                        res = False
-                                    printFunc(message)
-                            # запустить метод объекта
-                            if "method" in action:
-                                try:
-                                    method, args = self.parseMethod(self.tsa, dv,
-                                                                    action["method"], name)
-                                    if "decoration" in action:
-                                        decfunc, decargs = \
-                                            self.parseMethod(self.tsa, dv,
-                                                             action["decoration"], name)
-                                        method = decfunc(*decargs)(method)
-                                    res = method(*args)
-                                    if res is None:
-                                        res = False
-                                except CriticalError as e:
-                                    self.printERROR(str(e))
-                                    self.endFrame()
-                                    return False
-                                except self.native_error as e:
-                                    if hasattr(e, "addon") and e.addon:
-                                        self.printERROR(str(e.addon))
-                                    self.printERROR(str(e))
-                                    res = False
-                                except Exception as e:
-                                    error = short_traceback(*sys.exc_info())
-                                    self.printERROR(error)
-                                    res = False
-                            # запустить системную команду
-                            if "command" in action:
-                                hideout = action.get("hideout",False)
-                                cmdParam = map(lambda x:x.strip('"\''),
-                                               re.findall('["\'][^"\']+["\']|\S+',
-                                                          action["command"]))
-                                cmd = processProgress(*cmdParam)
-                                for line in cmd.progress():
-                                    if not hideout:
-                                        self.printSUCCESS(line)
-                                if cmd.failed():
-                                    lineCmd = cmd.pipe.stderr.read().split('\n')
-                                    for line in filter(None, lineCmd):
-                                        self.printERROR(line)
-                                res = cmd.success()
-                            if action.get("essential",True):
-                                result[name]=res
-                            failedPrint, failedMessage = (
-                                self.getFormatMessage(action, "failed_error",
-                                                      "failed_warning",
-                                                      "failed_message"))
-                            if not res and failedPrint:
-                                failedPrint(failedMessage)
-                            if task and res in (True,False,"skip"):
-                                self.endTask(res)
-                            logger.info("{name}: Result is {result}".format(
-                                name=name, result=res))
-                            if res is True:
-                                on_success = action.get('on_success',None)
-                                if on_success:
-                                    on_success()
-                                    #else:
-                                    #    print "[-] Skip ",name
-                    except KeyboardInterrupt as e:
-                        if action.get("essential",True):
-                            result[name]=False
-                        self.endTask(False)
-                        self.printWARNING(_("Task interrupted"))
-                        result["interrupt"] = False
-                        logger.info("{name}: Interrupeted".format(name=name))
-                    except self.native_error as e:
-                        if hasattr(e,"addon") and e.addon:
-                            self.printERROR(str(e.addon))
-                        self.printERROR(str(e))
-                        result[name]=False
-                        logger.info("{name}: Native error".format(name=name))
-                    except CriticalError as e:
-                        self.printERROR(str(e))
-                        self.endFrame()
-                        return False
-                    except BaseException as e:
-                        result[name]=False
-                        error = short_traceback(*sys.exc_info())
-                        self.printERROR("%s:%s"%(name,error))
-                        logger.info("{name}: Unknown exception {exp}".format(
-                            name=name, exp=e.__class__.__name__))
-        finally:
-            dv.close()
-        self.endFrame()
-        if any(x in (Tasks.FailedTask,
-                     Tasks.InterruptTask) for x in result):
-            return False
-        return True
-
diff --git pym/core/server/api_types.py pym/core/server/api_types.py
index 8fa670b..dd9f9dd 100644
--- pym/core/server/api_types.py
+++ pym/core/server/api_types.py
@@ -13,7 +13,6 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
-from calculate.core.server.task_set import TaskSetAggregation
 
 from soaplib.serializers.primitive import String, Integer, Boolean
 from soaplib.serializers.clazz import Array, ClassSerializer
@@ -85,35 +84,6 @@ class DataVarsSerializer(ClassSerializer):
         else:
             return (None,None)
 
-class MethodInfo(ClassSerializer):
-    """
-    Информация о методе
-    """
-    # идентификатор метода
-    name = String
-    # категория метода
-    category = String
-    # название метода
-    title = String
-    # пиктограмма метода
-    icon = String
-    # статус метода
-    status = String
-    # тип метода
-    method_type = String
-    # переменные
-    variables = Array(Array(String))
-
-    def __init__(self,name=None, category=None, title=None, icon=None,
-                 method_type=None, status=None):
-        super(MethodInfo,self).__init__()
-        self.name = name
-        self.category = category
-        self.title = title
-        self.icon = icon
-        self.status = status
-        self.method_type = method_type
-
 class ChoiceValue(DataVarsSerializer):
     typefield = String
     values = Array(String)
@@ -505,7 +475,47 @@ class Frame(ClassSerializer):
 class CoreWsdl:
     perm_denied = []
     perm_denied.append(Message (type = 'error', message = '403 Forbidden'))
-    method_calling = None
+
+    def callMethod(self,sid,info,logicClass=None,method=None,method_name=None,
+                   callbackRefresh=lambda sid,dv:True):
+        """
+        Common algorithm of method executing
+        """
+        try:
+            dv = self.get_cache(sid,method_name,"vars")
+            if not dv:
+                dv = getattr(self,"%s_vars"%method_name)()
+            else:
+                callbackRefresh(sid,dv)
+                dv.processRefresh()
+            if info:
+                checkonly = info.CheckOnly
+                checkall = info.CheckAll if hasattr(info,"CheckAll") else False
+            else:
+                checkonly = False
+                checkall = False
+            errors = map(lambda x:ReturnedMessage(**x),
+                     dv.checkGroups(info,allvars=checkall or not checkonly))
+            if errors:
+                return errors
+            if checkonly:
+                returnmess = ReturnedMessage(type = '', message = None)
+                return [returnmess]
+            install_meth = type("CommonCore",(self.Common,
+                                logicClass, object), {})
+            pid = self.startprocess(sid, target=install_meth,
+                            method=method,\
+                            method_name=method_name,
+                            args_proc = (dv,))
+            returnmess = ReturnedMessage(type = 'pid', message = pid)
+            returnmess.type = "pid"
+            returnmess.message = pid
+            dv = self.clear_cache(sid,method_name)
+            return [returnmess]
+        finally:
+            if dv:
+                self.set_cache(sid,method_name,"vars",dv,smart=False)
+        return []
 
     def callAction(self,sid,info,logicClass={},
                    method_name=None,
@@ -540,48 +550,25 @@ class CoreWsdl:
                 return [returnmess]
             if not actionClass:
                 return []
+            objs = {}
             from calculate.core.server.func import CommonLink
-            process_info = self.method_calling.get_process_API()
-            process_info.method_name = method_name
-            tsa = TaskSetAggregation(self.method_calling.get_messaging_API(),
-                                     process_info,
-                                     dv, logicClass)
-            action = actionClass(self.method_calling.get_messaging_API(),
-                                 process_info,
-                                 dv, tsa, method_name)
-            pid = self.method_calling.startprocess(sid, process_info,
-                                                   func=action.run,
-                                                   args_proc=())
-            returnmess = ReturnedMessage(type='pid', message=pid)
+            for k,v in logicClass.items():
+                objs[k] = type("Logic",(CommonLink, v, object), {})()
+            install_meth = type("CommonCore",(self.Common,
+                                actionClass, object), {})
+            pid = self.startprocess(sid, target=install_meth,
+                            method="run",
+                            method_name=method_name,
+                            args_proc = (objs,dv,))
+            returnmess = ReturnedMessage(type = 'pid', message = pid)
             returnmess.type = "pid"
             returnmess.message = pid
-            self.clear_cache(sid, method_name)
+            self.clear_cache(sid,method_name)
             dv = None
             return [returnmess]
         finally:
             if dv:
-                self.set_cache(sid, method_name, "vars", dv, smart=False)
-        return []
-
-    def callDirectory(self,sid,info,logicClass={}, method_name=None):
-        """
-        Общий алгоритм вызова метода получения списка действий
-        """
-        try:
-            dv = getattr(self,"%s_vars"%method_name)()
-            objs = {}
-            from calculate.core.server.func import CommonLink
-            for k,v in logicClass.items():
-                obj = type("Logic",(CommonLink, v, object), {})()
-                obj.set_link(self)
-                obj.clVars = dv
-                if hasattr(obj,"init"):
-                    obj.init()
-                ret = obj.get_methods()
-                if ret:
-                    return map(lambda x:MethodInfo(**x), ret)
-        finally:
-            dv.close()
+                self.set_cache(sid,method_name,"vars",dv,smart=False)
         return []
 
     def fixInstallLocalization(self,sid,dv):
diff --git pym/core/server/baseClass.py pym/core/server/baseClass.py
index 48e7459..6ccff6c 100644
--- pym/core/server/baseClass.py
+++ pym/core/server/baseClass.py
@@ -21,7 +21,6 @@ from soaplib.service import DefinitionBase
 from soaplib.serializers.primitive import String, Integer
 
 from soaplib.serializers.clazz import Array
-from api_types import MethodInfo
 
 from calculate.lib.cl_lang import getLazyLocalTranslate, setLocalTranslate
 setLocalTranslate('cl_core3',sys.modules[__name__])
@@ -286,9 +285,10 @@ class Basic (DefinitionBase) :
     def list_pid(self, sid):
         return  self.find_sid_pid_file (sid)
 
-    @rpc(Integer, String, _returns = Array(MethodInfo))
+    @rpc(Integer, String, _returns = Array(Array(String)))
     def get_methods ( self, sid, client_type):
-        return self.serv_get_methods (client_type)
+        return map(lambda x:map(str,x),
+               self.serv_get_methods (client_type))
 
     @rpc(Integer, _returns = Array(String))
     @LoadedMethods.core_method(rights=["get-sessions"])
diff --git pym/core/server/cl_server.py pym/core/server/cl_server.py
index 9d481a5..9aa9ff1 100644
--- pym/core/server/cl_server.py
+++ pym/core/server/cl_server.py
@@ -18,6 +18,7 @@ import sys, os
 import cert_cmd
 import pwd
 from itertools import *
+from calculate.core.server.func import clearDataVars
 
 from calculate.lib.cl_lang import setLocalTranslate
 setLocalTranslate('cl_core3',sys.modules[__name__])
@@ -26,6 +27,7 @@ _("User must be root")
 _('Failed to import %s')
 _('No module named %s')
 
+@clearDataVars
 def main(*args, **keywords):
     if os.path.basename(sys.argv[0]) != 'cl-core':
         parser = cert_cmd.parse(full=False)
@@ -123,7 +125,7 @@ def main(*args, **keywords):
                     return 1
 
                 import bootstrap
-                bootstrap.init(cert, key, cert_path, data_path, certbase, args,
+                bootstrap.init(cert, key, cert_path, data_path, certbase, args, \
                                port, args.bootstrap_user_name)
                 return 0
             if args.revoke_cert_id:
@@ -172,7 +174,6 @@ def main(*args, **keywords):
     # importing other modules
     from func import initialization
     other_mod = initialization(cl_wsdl)
-    print other_mod
     #try:
     pack = "calculate.core.server"
     import importlib
@@ -187,13 +188,13 @@ def main(*args, **keywords):
     if args.method or args.list_methods:
         from local_call import local_method, LocalCall
         CombinedServerClass = type("CombinedServerClass",
-                                   tuple(other_mod), {})
-        return local_method(CombinedServerClass, args, unknown_args, ob)
+                                   tuple([LocalCall] + other_mod), {})
+        return local_method(CombinedServerClass, args, unknown_args)
 
-    CombinedServerClass = type("CombinedServerClass", tuple(other_mod), {})
+    CombinedServerClass = type ("CombinedServerClass", tuple(other_mod), {})
 
     from server_class import ClApplication, OpenSSLAdapter
-    App = ClApplication([CombinedServerClass], 'tns', log=file_logger)
+    App = ClApplication([CombinedServerClass],'tns', log = file_logger)
     tc = App.get_service(CombinedServerClass)
 
     if args.create_symlink:
@@ -205,8 +206,8 @@ def main(*args, **keywords):
     cert_cmd.create_path(data_path, certbase, rights, group_rights,local_data_path)
 
     # set all path
-    tc.set_paths(data_path, certbase, serv_certbase, rights, group_rights,
-                sids, pids, sids_pids, sids_file, pids_file, max_sid,
+    tc.set_paths (data_path, certbase, serv_certbase, rights, group_rights, \
+                sids, pids, sids_pids, sids_file, pids_file, max_sid, \
                 max_pid, cert_path, LOG_FILENAME, cert, key)
     # запустить выполнение регулярных задач (мониторинг и т.д.)
     tc.run_tasks()
@@ -214,9 +215,8 @@ def main(*args, **keywords):
     max_num = 99999999
     from cherrypy.wsgiserver import CherryPyWSGIServer, WSGIPathInfoDispatcher
     dispatcher = WSGIPathInfoDispatcher( { '' : App } )
-    server = CherryPyWSGIServer(('0.0.0.0', port), dispatcher,
-                                numthreads=10, max=max_num,
-                                request_queue_size=max_num)
+    server = CherryPyWSGIServer(('0.0.0.0', port), dispatcher,\
+    numthreads = 10, max = max_num, request_queue_size = max_num)
 
     print _("listening to https://0.0.0.0:%d") % (port)
     print _("wsdl is located at: https://0.0.0.0:%d/?wsdl") %(port)
diff --git pym/core/server/func.py pym/core/server/func.py
index f2e03c1..3b2cfd9 100644
--- pym/core/server/func.py
+++ pym/core/server/func.py
@@ -1,6 +1,6 @@
 #-*- coding: utf-8 -*-
 
-# Copyright 2012-2014 Calculate Ltd. http://www.calculate-linux.org
+# Copyright 2012-2013 Calculate Ltd. http://www.calculate-linux.org
 #
 #  Licensed under the Apache License, Version 2.0 (the "License");
 #  you may not use this file except in compliance with the License.
@@ -18,25 +18,33 @@ import pickle, random
 import threading
 import sys, os, re
 from os import path
+import traceback
 from traceback import print_exc
+from calculate.lib.cl_log import log
 from calculate.lib.utils.colortext import convert_console_to_xml
-from api_types import ReturnProgress, MethodInfo
-from calculate.lib.cl_lang import setLocalTranslate, getLazyLocalTranslate
+from api_types import ReturnProgress,ViewParams,Integer,ViewInfo
+from loaded_methods import LoadedMethods
+from calculate.lib.cl_lang import setLocalTranslate,getLazyLocalTranslate
+setLocalTranslate('cl_core3',sys.modules[__name__])
+__ = getLazyLocalTranslate(_)
 
-from calculate.lib.utils.files import (process, readFile, makeDirectory)
+from calculate.lib.utils.files import (process,readFile,processProgress,
+                                       makeDirectory)
+from calculate.lib.datavars import DataVarsError, CriticalError
+from calculate.lib.cl_template import TemplatesError
 from calculate.lib.utils.content import getCfgFiles
-from calculate.core.server.api_types import ViewInfo
+from itertools import *
+
+from soaplib.serializers.primitive import String, Integer, Any, Boolean
+from soaplib.serializers.clazz import Array
+from soaplib.service import rpc, DefinitionBase
+from calculate.core.server.api_types import ReturnedMessage,CommonInfo
+from calculate.core.server.api_types import ChoiceValue, Table, Option, Field, \
+                                           GroupField, ViewInfo, ViewParams
 from calculate.lib.cl_template import Template
+from calculate.lib.datavars import DataVars
 from loaded_methods import LoadedMethods
-
 from calculate.core.depricated import safetyWrapper
-from calculate.lib.utils.tools import short_traceback as shortTraceback
-from action import Action, ActionError, Tasks
-from wsdl_meta import WsdlBase
-
-setLocalTranslate('cl_core3', sys.modules[__name__])
-__ = getLazyLocalTranslate(_)
-
 
 class CommonMethods:
     def dispatchConf(self,filesApply=None):
@@ -203,8 +211,7 @@ class CommonLink(object):
         """
         return self.com.dispatchConf(filesApply)
 
-    def applyTemplates(self, target=None, useClt=None, cltFilter=False,
-                       root=None,
+    def applyTemplates(self,target=None,useClt=None,cltFilter=False,root=None,
                        useDispatch=True):
         """
         Вызов наложения шаблонов
@@ -215,7 +222,7 @@ class CommonLink(object):
         """
         Вызов установки значения для переменной
         """
-        return self.com.setVariable(varname, varvalue)
+        return self.com.setVariable(varname,varvalue)
 
     def writeFile(self):
         """
@@ -393,6 +400,522 @@ class CommonLink(object):
         """
         self.com.endGroup()
 
+class ActionError(Exception):
+    pass
+
+class Tasks:
+    """
+    Класс для создания проверок необходимости запуска задачи в зависимости
+    от результатра работы предыдущих задач
+    """
+    def __init__(self,check):
+        self.check = check
+
+    def __call__(self,result):
+        return self.check(result)
+
+    def __or__(self,y):
+        return Tasks(lambda result:self(result) or y(result))
+
+    def __ror__(self,y):
+        return Tasks(lambda result:y(result) or self(result))
+
+    def __and__(self,y):
+        return Tasks(lambda result:self(result) and y(result))
+
+    def __rand__(self,y):
+        return Tasks(lambda result:y(result) and self(result))
+
+    def __invert__(self):
+        return Tasks(lambda result:not self(result))
+
+    @classmethod
+    def success_all(cls,*tasks):
+        """
+        Все указанные задачи выполнены и выполнены без ошибок
+        """
+        return Tasks(
+            lambda result:all(x in result and result[x] for x in tasks))
+
+    @classmethod
+    def success_one_of(cls,*tasks):
+        """
+        Хотя бы одна из задач выполнена и хотя бы одна из выполненных без ошибок
+        """
+        return Tasks(
+            lambda result:any(result[x] for x in tasks if x in result))
+
+    @classmethod
+    def success(cls,inessential=[]):
+        """
+        Все ранее запущенные задачи успешно завершены, результат задач
+        inessential не важен
+        """
+        return Tasks(lambda result:all(result[x] for x in result
+                                       if x not in inessential))
+
+    @classmethod
+    def failed(cls,inessential=[]):
+        """
+        Хотя бы одна из задач завершилась неудачно, результат задач
+        inessential не важен
+        """
+        return Tasks(lambda result:any(not result[x] for x in result
+                                       if x not in inessential))
+
+    @classmethod
+    def failed_all(cls,*tasks):
+        """
+        Выполнена хотя бы одна задача и все те, которые выполнены с ошибкой
+        """
+        return Tasks(
+            lambda result:any(not result[x] for x in tasks if x in result))
+
+    @classmethod
+    def failed_one_of(cls,*tasks):
+        """
+        Хотя бы одна из указанных задач выполнена и выполнена с ошибкой
+        """
+        return Tasks(
+            lambda result:any(x in result and not result[x] for x in tasks))
+
+    @classmethod
+    def has(cls,*tasks):
+        """
+        Был запуск всех перечисленных задач
+        """
+        return Tasks(lambda result:all(x in result for x in tasks))
+
+    @classmethod
+    def hasnot(cls,*tasks):
+        """
+        Не было запуска ни одной из перечисленных задач
+        """
+        return Tasks(lambda result:all(x not in result for x in tasks))
+
+    @classmethod
+    def result(cls,task,eq=None,ne=None):
+        if eq:
+            wrapper = lambda result: task in result and result[task]==eq
+        elif ne:
+            wrapper = lambda result: not task in result or result[task]!=ne
+        else:
+            wrapper = lambda result: task in result and result[task]
+        return Tasks(wrapper)
+
+    @classmethod
+    def has_any(cls,*tasks):
+        """
+        Был запуск любой из задач
+        """
+        return Tasks(lambda result:any(x in result for x in tasks))
+
+class Action:
+    """
+    Класс для реализации выполнения действия
+    """
+    #default = {'depend':Tasks.success(),
+    #           # прятать вывод
+    #           'hideout':False,
+    #           # задача важна, в случае False результат не сохраняется в self.result
+    #           'essential':True}
+
+    # список выполняемых задач
+    tasks = []
+    # список исключений, которые выводятся в сокращенном формате (ожидаемые ошибки)
+    # остальные выводятся с именем модуля и номером строки
+    native_error = ()
+
+    # сообщение об удачном завершении действия
+    successMessage = None
+    # сообщение при ошибке
+    failedMessage = None
+    # сообщение о прерывании
+    interruptMessage = None
+
+    # список задач для дейсвия
+    tasks = []
+    # добавить стандартные сообщения в конце
+    finishMessage = True
+
+    def __init__(self):
+        if self.finishMessage:
+            tasks = []
+            if self.failedMessage:
+                tasks.append(
+                 # вывести сообщение в случае ошибки
+                 {'name':'failed',
+                  'error': self.failedMessage,
+                  'depend': (Tasks.failed() & Tasks.hasnot("interrupt"))})
+            if self.successMessage:
+                tasks.append(
+                 # вывести сообщение в случае успеха
+                 {'name':'success',
+                  'message': self.successMessage,
+                  'depend': (Tasks.success() & Tasks.hasnot("failed"))})
+            if self.interruptMessage:
+                tasks.append(
+                 # вывести сообщение о том, что действие прервано
+                 {'name':'intmessage',
+                  'error':self.interruptMessage,
+                  'depend': (Tasks.has("interrupt"))})
+            self.tasks = self.tasks + tasks
+        self.group_name = ""
+        self.clVars = None
+
+    @classmethod
+    def program(cls,progName):
+        """
+        Проверить наличие программы
+        """
+        return lambda dv:bool(progPath(progName))
+
+    @classmethod
+    def packageInstalled(cls,pkg):
+        """
+        Проверить было ли обновление пакета
+        """
+        return lambda dv:False
+
+    @classmethod
+    def variables(cls,*varnames):
+        """
+        Передать переменные как аргументы, поддерживается True,False
+        """
+        return lambda dv:[dv.Get(x) if not x in (True,False) else x \
+                          for x in varnames]
+
+    reMethod = re.compile("^([A-Za-z]+)\.([A-Za-z0-9_]+)\(([^)]*)\)$")
+    reMessageVars = re.compile("\{([^}]+)\}")
+
+    def parseMethod(self,objs,dv,s,task):
+        """
+        Разобрать строку метода, на объект, метод, аргументы
+        """
+        result = self.reMethod.search(s)
+        if not result:
+            raise ActionError(_("Wrong method for task %s")%task)
+        objname,methodname,args = result.groups()
+        if not objname in objs:
+            raise ActionError(_("Object %s not found")%objname)
+        obj = objs[objname]
+        if not hasattr(obj,methodname):
+            raise ActionError(_("Method {method} for {obj} not found").
+                        format(method=methodname,obj=objname))
+
+        def _convertMethodArg(param):
+            """
+            Конвертировать аргумент для метода, взять по словарю,
+            либо строка - имя переменной
+            """
+            param = param.strip()
+            mapStd = {'True':True,
+                      'False':False,
+                      'None':None,
+                      '""':"",
+                      "''":""}
+            if param in mapStd:
+                return mapStd[param]
+            if param.isdigit():
+                return int(param)
+            if param.startswith('"') and param.endswith('"'):
+                return param.strip('"')
+            if param == 'eachvar':
+                return self.eachvar
+            _type = dv.getInfo(param).type
+            if _type == "int":
+                return dv.GetInteger(param)
+            if _type == "bool":
+                return dv.GetBool(param)
+            return dv.Get(param)
+
+        if args:
+            args = map(_convertMethodArg, args.split(','))
+        else:
+            args = ()
+        return getattr(obj,methodname),args
+
+    def formatMessage(self,dv,message):
+        """
+        Вставить значения переменных в текст сообщения
+        """
+
+        class TextTrasformer:
+            def first_letter_upper(self, s):
+                return "%s%s" % (s[0].upper(), s[1:])
+
+        tt = TextTrasformer()
+
+        def replace_value(match):
+            var = match.group(1)
+            if ":" in var:
+                var, func = var.split(':')
+            else:
+                func = None
+            if var == "eachvar":
+                val = self.eachvar
+            else:
+                val = dv.Get(var)
+            if type(val) == list:
+                val = ",".join(val)
+            if func:
+                if hasattr(tt, func):
+                    val = getattr(tt, func)(val)
+                else:
+                    val = getattr(val, func)()
+            return "{0}".format(val)
+
+        return self.reMessageVars.sub(replace_value, str(message))
+
+    def runCondition(self,funcCondition):
+        """
+        Запустить метод проверки условия (если аргумент называется Get,
+        то передавать в него не объект DataVars а метод Get,
+        если у нет аргументов, то не передавать туда аргументы
+        """
+        args = []
+        arg_count = funcCondition.func_code.co_argcount
+        for param_name in funcCondition.func_code.co_varnames[:arg_count]:
+            if param_name in ('Get','Select','ZipVars'):
+                args.append(getattr(self.clVars, param_name))
+            elif param_name == 'eachvar':
+                args.append(self.eachvar)
+            else:
+                args.append(self.clVars)
+        return funcCondition(*args)
+
+    def getFormatMessage(self,action,*fields):
+        """
+        Получить сообщение для вывода среди нескольких с приоритетом и
+        метод вывода
+        """
+        for field in (x for x in fields if x in action):
+            if "error" in field:
+                printFunc = self.printERROR
+            elif "warning" in field:
+                printFunc = self.printWARNING
+            else:
+                printFunc = self.printSUCCESS
+            return printFunc,self.formatMessage(self.clVars,action[field])
+        return None,None
+
+    def get_tasks(self, result):
+        """
+        Герератор задач (поддержка линейной обработки задач в группах)
+        """
+        for task in self.tasks:
+            if "group" in task:
+                if all(self.get_condition_context(task, result).values()):
+                    self.group_name = task["group"]
+                    for action in task["tasks"]:
+                        yield action
+                    if not self.group_name:
+                        self.endGroup()
+                    else:
+                        self.group_name = ""
+            else:
+                yield task
+
+    def get_condition_context(self, action, result):
+        """
+        Получить результаты проверки по зависимосятм и условиям
+        """
+        group, op, name = action.get("name",
+                                     "<unknown>").rpartition(':')
+        # проверить по результатам
+        # если указанно группа к имени с '!', то проверяется
+        # только условие принадлежности задачи к группе
+        if group and group.endswith('!'):
+            group = group.strip('!')
+            depend = [Tasks.success_all(group)]
+        else:
+            depend = action.get("depend", Tasks.success())
+            depend = (depend
+                      if type(depend) in (list, tuple) else [depend])
+            if group:
+                depend.append(Tasks.success_all(group))
+        depend_result = all([x(result) for x in depend])
+        # проверить по условиям
+        if depend_result:
+            condition_funcs = action.get("condition", lambda dv: True)
+            condition_funcs = (condition_funcs
+                               if type(condition_funcs) in (list, tuple)
+                               else [condition_funcs])
+            condition_result = all(
+                [self.runCondition(x) for x in condition_funcs])
+        else:
+            condition_result = True
+        return {'condition': condition_result, 'depend': depend_result}
+
+    def run(self, objs, dv):
+        """Запустить список действий"""
+        class StubLogger:
+            def info(self,s):
+                pass
+        result = {}
+
+        self.group_name = ""
+        self.clVars = dv
+        if dv.Get('cl_env_debug_set') == 'off' or \
+            dv.Get('cl_ebuild_phase'):
+            logger = StubLogger()
+        else:
+            logger = log("core-action.log",
+                         filename="/var/log/calculate/core-action.log",
+                         formatter="%(asctime)s - %(levelname)s - %(message)s")
+        for obj in objs.values():
+            obj.set_link(self)
+            obj.clVars = dv
+            if hasattr(obj,"init"):
+                obj.init()
+        try:
+            self.beginFrame()
+            logger.info("Start {methodname}".format(
+                methodname=self.method_name))
+            for action in self.get_tasks(result):
+                foreach = action.get("foreach","")
+                if foreach:
+                    foreach = self.clVars.Get(foreach)
+                else:
+                    foreach = [""]
+                self.eachvar = ""
+                for eachvar in foreach:
+                    self.eachvar = eachvar
+                    group,op,name = action.get("name",
+                                               "<unknown>").rpartition(':')
+                    res = True
+                    task = False
+                    try:
+                        run_context = self.get_condition_context(action, result)
+                        actinfo = "Run" if all(run_context.values()) else "Skip"
+                        logger.info(
+                            "{action} {name}: condition: {condition}, "
+                            "depend: {depend}".format(
+                                action=actinfo,
+                                name=name,
+                                condition=run_context['condition'],
+                                depend=run_context['depend']))
+
+                        elsePrint, elseMessage = (
+                            self.getFormatMessage(action,"else_error",
+                                              "else_warning","else_message"))
+                        if (run_context['depend'] and
+                                not run_context['condition'] and elseMessage):
+                            if "else_error" in action:
+                                if action.get("essential",True):
+                                    result[name]=False
+                            elsePrint(elseMessage)
+                        if all(run_context.values()):
+                            self.writeFile()
+                            if self.group_name:
+                                self.startGroup(str(self.group_name))
+                                self.group_name = None
+                            printFunc,message = self.getFormatMessage(
+                                    action,"error","warning","message")
+                            if "confirm" in action and message:
+                                result[name] = \
+                                    self.askConfirm(str(message),
+                                                    action["confirm"])
+                                continue
+                            elif message:
+                                # если действие с командой
+                                if not "error" in action and \
+                                    "method" in action or "command" in action:
+                                    self.startTask(str(message))
+                                    task = True
+                                # действие содержит только сообщение
+                                else:
+                                    if "error" in action:
+                                        res = False
+                                    printFunc(message)
+                            # запустить метод объекта
+                            if "method" in action:
+                                try:
+                                    method, args = self.parseMethod(objs,dv,
+                                                      action["method"], name)
+                                    if "decoration" in action:
+                                        decfunc, decargs = \
+                                            self.parseMethod(objs, dv,
+                                                     action["decoration"], name)
+                                        method = decfunc(*decargs)(method)
+                                    res = method(*args)
+                                    if res is None:
+                                        res = False
+                                except CriticalError as e:
+                                    self.printERROR(str(e))
+                                    self.endFrame()
+                                    return False
+                                except self.native_error as e:
+                                    if hasattr(e, "addon") and e.addon:
+                                        self.printERROR(str(e.addon))
+                                    self.printERROR(str(e))
+                                    res = False
+                                except Exception as e:
+                                    error = shortTraceback(*sys.exc_info())
+                                    self.printERROR(error)
+                                    res = False
+                            # запустить системную команду
+                            if "command" in action:
+                                hideout = action.get("hideout",False)
+                                cmdParam = map(lambda x:x.strip('"\''),
+                                           re.findall('["\'][^"\']+["\']|\S+',
+                                           action["command"]))
+                                cmd = processProgress(*cmdParam)
+                                for line in cmd.progress():
+                                    if not hideout:
+                                        self.printSUCCESS(line)
+                                if cmd.failed():
+                                    lineCmd = cmd.pipe.stderr.read().split('\n')
+                                    for line in filter(None, lineCmd):
+                                        self.printERROR(line)
+                                res = cmd.success()
+                            if action.get("essential",True):
+                                result[name]=res
+                            failedPrint, failedMessage = (
+                                self.getFormatMessage(action,"failed_error",
+                                         "failed_warning","failed_message"))
+                            if not res and failedPrint:
+                                failedPrint(failedMessage)
+                            if task and res in (True,False,"skip"):
+                                self.endTask(res)
+                            logger.info("{name}: Result is {result}".format(
+                                name=name, result=res))
+                            if res is True:
+                                on_success = action.get('on_success',None)
+                                if on_success:
+                                    on_success()
+                        #else:
+                        #    print "[-] Skip ",name
+                    except KeyboardInterrupt as e:
+                        if action.get("essential",True):
+                            result[name]=False
+                        self.endTask(False)
+                        self.printWARNING(_("Task interrupted"))
+                        result["interrupt"] = False
+                        logger.info("{name}: Interrupeted".format(name=name))
+                    except self.native_error as e:
+                        if hasattr(e,"addon") and e.addon:
+                            self.printERROR(str(e.addon))
+                        self.printERROR(str(e))
+                        result[name]=False
+                        logger.info("{name}: Native error".format(name=name))
+                    except CriticalError as e:
+                        self.printERROR(str(e))
+                        self.endFrame()
+                        return False
+                    except BaseException as e:
+                        result[name]=False
+                        error = shortTraceback(*sys.exc_info())
+                        self.printERROR("%s:%s"%(name,error))
+                        logger.info("{name}: Unknown exception {exp}".format(
+                            name=name, exp=e.__class__.__name__))
+        finally:
+            dv.close()
+        self.endFrame()
+        if any(x in ("failed","interrupt") for x in result):
+            return False
+        return True
+
 def commonView(self,sid,params,arg):
     dv = self.get_cache(sid,arg,"vars")
     if not dv:
@@ -403,6 +926,61 @@ def commonView(self,sid,params,arg):
     self.set_cache(sid, arg, "vars",dv,smart=False)
     return view
 
+def catchExcept(*skipException):
+    class wrapper:
+        def __init__(self,f):
+            self.f = f
+            self.func_name = f.func_name
+            self.func_code = f.func_code
+            self.__doc__ = f.__doc__
+            self.__name__ = f.__name__
+        
+        def __call__(self,*args,**kwargs):
+            try:
+                return self.f(*args,**kwargs)
+            except BaseException as e:
+                from calculate.core.server.api_types import ViewInfo,GroupField,Field
+                view = ViewInfo(groups=[])
+                group = GroupField(name=_("Error"),last=True)
+                group.fields = []
+                group.fields.append(Field(
+                        name = "error",
+                        label = str(e),
+                        default = 'color:red;',
+                        element = "error"))
+                view.groups.append(group)
+                if not any(isinstance(e,x) for x in skipException):
+                    print shortTraceback(*sys.exc_info())
+                    #for i in apply(traceback.format_exception, sys.exc_info()):
+                    #    print i,
+
+                return view
+    return wrapper
+
+def shortTraceback(e1,e2,e3):
+    """
+    Return short traceback
+    """
+    frame = e3
+    for i in apply(traceback.format_exception, (e1,e2,e3)):
+        print i,
+    while(frame.tb_next):
+        frame = frame.tb_next
+    module,part = os.path.split(frame.tb_frame.f_code.co_filename)
+    if part.endswith('.py'):
+        part = part[:-3]
+    fallbackmod = part
+    modname = [part]
+    while module != '/' and not module.endswith('site-packages'):
+        module,part = os.path.split(module)
+        modname.insert(0,part)
+    if module.endswith('site-packages'):
+        modname = ".".join(modname)
+    else:
+        modname = fallbackmod
+    return "%s:%s(%s:%s)"%(e1.__name__,str(e2),modname,frame.tb_lineno)
+
+
 class ActiveClientStatus:
     Success = 0
     Failed = 1
@@ -447,13 +1025,6 @@ class CoreWsdl():
         else:
             return ActiveClientStatus.WrongSID
 
-    def print_ret_result(f):
-        def wrapper(*argv, **kwarg):
-            ret = f(*argv)
-            print "DEBUG",f,ret
-            return ret
-        return wrapper
-
     def serv_get_methods(self, client_type):
         curThread = threading.currentThread()
         certificate = curThread.client_cert
@@ -463,41 +1034,54 @@ class CoreWsdl():
         rights = self.serv_view_cert_right(cert_id, self.data_path,client_type)
         return_list = []
         if client_type == "console":
-            methods = self.return_conMethod()
+            for meth in self.return_conMethod():
+                right_flag = True
+                for right in LoadedMethods.rightsMethods[meth[1]]:
+                    if not right in rights:
+                        right_flag = False
+                if right_flag:
+                    return_list.append(meth)
+            if not len(return_list):
+                return [['0','0']]
+            return return_list
         else:
-            methods = self.return_guiMethod()
-        curThread = threading.currentThread()
-        for meth in methods:
-            right_flag = True
-            for right in LoadedMethods.rightsMethods[meth.name]:
-                if not right in rights:
-                    right_flag = False
-            if right_flag:
-                return_list.append(meth)
-        return return_list
-
-    def all_methods(self, filter_func):
-        """
-        Вернуть список методов
-        """
-        from loaded_methods import LoadedMethods
-        for x in filter(filter_func,
-                        LoadedMethods.methods_info):
-            yield  MethodInfo(x['name'],
-                    str(x['category']), str(x['title']),
-                    x['icon'], x['type'])
-
+            curThread = threading.currentThread()
+            for meth in self.return_guiMethod():
+                right_flag = True
+                for right in LoadedMethods.rightsMethods[meth[1]]:
+                    if not right in rights:
+                        right_flag = False
+                if right_flag:
+                    return_list.append(meth)
+            if not len(return_list):
+                return [['0','0']]
+            return return_list
+            #return self.return_guiMethod()
+
+    # return a list of methods for the console as list
     def return_conMethod(self):
-        """
-        Вернуть список консольных методов
-        """
-        return self.all_methods(lambda x:x['command'])
+        from loaded_methods import LoadedMethods
+        results = []
+        for item in LoadedMethods.conMethods:
+            temp = []
+            temp.append(item)
+            for i in LoadedMethods.conMethods[item]:
+                temp.append(i)
+            results.append (temp)
+        return results
 
+    # return a list of methods for the GUI as list
     def return_guiMethod(self):
-        """
-        Вернуть список GUI методов
-        """
-        return self.all_methods(lambda x:x['gui'])
+        from loaded_methods import LoadedMethods
+        results = []
+        for item in LoadedMethods.guiMethods:
+            for i in range(0, len(LoadedMethods.guiMethods[item]),3):
+                temp = []
+                temp.append(item)
+                for j in range (3):
+                    temp.append(LoadedMethods.guiMethods[item][i+j])
+                results.append (temp)
+        return results
 
     # get available sessions
     def serv_get_sessions(self):
@@ -601,11 +1185,8 @@ class CoreWsdl():
 
         def getAnswer(self):
             import time
-            from calculate.core.server.gen_pid import ProcessStatus
-            self.setStatus(ProcessStatus.Question)
             while self.process_dict['answer'] == None:
                 time.sleep (0.5)
-            self.setStatus(ProcessStatus.Worked)
             res = self.process_dict['answer']
             self.process_dict['answer'] = None
             self.frame_list.pop(len(self.frame_list) - 1)
@@ -782,17 +1363,15 @@ class CoreWsdl():
 
     # wrap all method
     def target_helper(self, com, target_proc, method_name, *args_proc):
-        from calculate.core.server.gen_pid import ProcessStatus
         if not os.path.exists(self.pids):
-            try:
-                os.mkdir(self.pids)
-            except OSError:
-                pass
+            os.system('mkdir %s' %self.pids)
+#        PID_FILE  =  self.pids + '/%d.pid'%com.pid
         import datetime
         dat = datetime.datetime.now()
 
-        com.process_dict['status'] = ProcessStatus.Worked
+        com.process_dict['status'] = 1
         com.process_dict['time'] = dat
+        #if method_name:
         com.process_dict['method_name'] = method_name
         com.process_dict['name'] = target_proc.__func__.__name__
 
@@ -806,17 +1385,17 @@ class CoreWsdl():
             fd.close()
         try:
             if result == True:
-                com.setStatus (ProcessStatus.SuccessFinished)
+                com.setStatus (0)
                 com.writeFile()
             elif result == False:
-                if com.getStatus() in (ProcessStatus.Question, ProcessStatus.Worked):
-                    com.setStatus (ProcessStatus.FailedFinished)
+                if com.getStatus() == 1:
+                    com.setStatus (2)
                 com.writeFile()
             else:
-                if com.getStatus() in (ProcessStatus.Question, ProcessStatus.Worked):
-                    com.setStatus (ProcessStatus.FailedFinished)
+                if com.getStatus() == 1:
+                    com.setStatus (2)
                 else:
-                    com.setStatus (ProcessStatus.SuccessFinished)
+                    com.setStatus (0)
                 com.writeFile()
             try:
                 if com.getProgress() < 100 and com.getProgress() > 0:
@@ -874,11 +1453,11 @@ class CoreWsdl():
                 result = []
                 if client_type == 'console':
                     for meth_list in self.return_conMethod():
-                        for right in LoadedMethods.rightsMethods[meth_list.name]:
+                        for right in LoadedMethods.rightsMethods[meth_list[1]]:
                             result.append(right)
                 else:
                     for meth_list in self.return_guiMethod():
-                        for right in LoadedMethods.rightsMethods[meth_list.name]:
+                        for right in LoadedMethods.rightsMethods[meth_list[1]]:
                             result.append(right)
                 result = uniq(result)
                 results = result
@@ -1024,7 +1603,9 @@ def initialization(cl_wsdl):
     for pack in cl_wsdl:
         if pack:
             module_name = '%s.wsdl_%s'% (pack.replace("-","."),
-                                         pack.rpartition("-")[2])
+                                            pack.rpartition("-")[2])
+            #try:
+            import calculate.core.wsdl_core
             import importlib
             cl_wsdl_core = importlib.import_module(module_name)
             try:
@@ -1038,10 +1619,12 @@ def new_key_req(key, cert_path, serv_host_name, port):
     from create_cert import generateRSAKey, makePKey, makeRequest,\
                                     passphrase_callback
     rsa = generateRSAKey()
-    rsa.save_key(key+'_pub', cipher=None, callback=passphrase_callback)
+    rsa.save_key(key+'_pub',\
+                        cipher=None, callback=passphrase_callback)
 
     pkey = makePKey(rsa)
-    pkey.save_key(key, cipher=None, callback=passphrase_callback)
+    pkey.save_key(key,\
+                        cipher=None, callback=passphrase_callback)
 
     req = makeRequest(rsa, pkey, serv_host_name, port)
     if not req:
@@ -1056,3 +1639,179 @@ def uniq(seq):
     seen = set()
     seen_add = seen.add
     return [ x for x in seq if x not in seen and not seen_add(x)]
+
+class WsdlMeta(type):
+    """
+    Метакласс для создания методов по атрибуту methdos
+    """
+    datavars = {}
+    def __new__(cls,name,bases,attrs):
+        if "methods" in attrs:
+            for method in attrs["methods"]:
+                attrs[method['method_name']] = cls.callerConstructor(**method)
+                attrs["%s_vars"%method['method_name']] = cls.datavarsConstructor(**method)
+                attrs["%s_view"%method['method_name']] = cls.viewConstructor(**method)
+        return type.__new__(cls, name,bases,attrs)
+
+    @classmethod
+    def closeDataVars(cls):
+        for dv in WsdlMeta.datavars.values():
+            dv.close()
+
+    @classmethod
+    def createInfoObj(cls,**kwargs):
+        """
+        Создание передаваемой структуры данных для WSDL
+        """
+        def typeConvert(s):
+            if "bool" in s:
+                return Boolean
+            elif "table" in s:
+                return Array(Array(String))
+            elif "list" in s:
+                return Array(String)
+            else:
+                return String
+        d = {}
+        if kwargs['datavars'] in WsdlMeta.datavars:
+            dv = WsdlMeta.datavars[kwargs['datavars']]
+        else:
+            dv = DataVars()
+            dv.importVariables()
+            dv.importVariables('calculate.%s.variables'%kwargs['datavars'])
+            dv.defaultModule = kwargs['datavars']
+            WsdlMeta.datavars[kwargs['datavars']] = dv
+        def group(*args,**kwargs):
+            for v in chain(kwargs.get('normal',()),kwargs.get('expert',())):
+                d[v] = typeConvert(dv.getInfo(v).type)
+        for gr in kwargs['groups']:
+            gr(group)
+        #if "brief" in kwargs:
+        if not "cl_page_count" in d:
+            d["CheckOnly"] = Boolean
+        return d
+
+    @classmethod
+    def callerConstructor(cls,**kwargs):
+        """
+        Конструктор для создания метода-вызова для действия
+        """
+        def wrapper(self, sid, info):
+            # костыль для локализации install
+            callbackRefresh = self.fixInstallLocalization \
+                if kwargs['method_name'] == 'install' else lambda dv,sid:True
+            return self.callAction(sid,info,logicClass=kwargs['logic'],
+                                   actionClass=kwargs['action'],
+                                   method_name=kwargs['method_name'],
+                                   callbackRefresh=callbackRefresh)
+        wrapper.func_name = kwargs['method_name']
+        func = LoadedMethods.core_method(category=kwargs.get('category',None),
+                           title=kwargs['title'],
+                           image=kwargs.get('image',None),
+                           gui=kwargs['gui'],
+                           user=kwargs.get('user',False),
+                           command=kwargs.get('command',None),
+                           rights=kwargs['rights'])(wrapper)
+        if "--start" in sys.argv:
+            infoObj = cls.createInfoObj(**kwargs)
+            infoClass = type("%sInfo"%kwargs["method_name"],(CommonInfo,),infoObj)
+            return rpc(Integer,infoClass,_returns = Array(ReturnedMessage))(func)
+        else:
+            return func
+
+    @classmethod
+    def modifyDatavars(cls,dv,data):
+        """
+        Поменять значения в datavars согласно data
+        """
+        # установить заданные значения (!) принудительная установка
+        for k,v in data.items():
+            # если значение функция
+            if callable(v):
+                v = v(dv)
+            dv.Set(k.strip('!'),v,force=k.endswith('!'))
+
+    @classmethod
+    def viewConstructor(cls,**kwargs):
+        """
+        Конструктор для создания метода-представления
+        """
+        def wrapper(self,sid,params):
+            dv = self.get_cache(sid,kwargs["method_name"],"vars")
+            langChanged = False
+            if kwargs["groups"]:
+                def group(*args,**kwargs):
+                    if isinstance(kwargs.get('normal',()), (unicode, str)):
+                        raise DataVarsError(_("Wrong normal varaiables list"))
+                    if isinstance(kwargs.get('expert',()), (unicode, str)):
+                        raise DataVarsError(_("Wrong expert varaiables list"))
+                for gr in kwargs['groups']:
+                    gr(group)
+            if not dv:
+                dv = getattr(self,"%s_vars"%kwargs["method_name"])()
+                if hasattr(params,"clienttype"):
+                    if params.clienttype == 'gui' and "guivars" in kwargs:
+                        cls.modifyDatavars(dv,kwargs['guivars'])
+                    if params.clienttype != 'gui' and "consolevars" in kwargs:
+                        cls.modifyDatavars(dv,kwargs['consolevars'])
+            else:
+                # костыль для метода install, который меняет локализацию
+                # интрефейса в зависимости от выбранного параметра lang
+                if kwargs["method_name"] == 'install':
+                    langChanged = self.fixInstallLocalization(sid,dv)
+                    lang = dv.Get('install.os_install_locale_lang')
+                    self.set_cache(sid,"install","lang",lang,smart=False)
+                dv.processRefresh()
+            self.set_cache(sid, kwargs["method_name"], "vars",dv,smart=False)
+            if "brief" in kwargs and "name" in kwargs['brief']:
+                brief_label = str(kwargs['brief']['name'])
+            else:
+                brief_label = None
+            if kwargs["groups"]:
+                view = ViewInfo(dv,viewparams=params,
+                        has_brief="brief" in kwargs,
+                        allsteps=langChanged,
+                        brief_label=brief_label)
+            else:
+                view = ViewInfo()
+            return view
+        wrapper.func_name = "%s_view"%kwargs['method_name']
+        return rpc(Integer, ViewParams, _returns = ViewInfo)(
+               catchExcept(kwargs.get("native_error",()))(wrapper))
+               
+    @classmethod
+    def datavarsConstructor(cls,**kwargs):
+        """
+        Конструктор для создания метода описания параметров
+        """
+        def wrapper(self,dv=None):
+            if not dv:
+                dv = DataVars()
+                dv.importVariables()
+                dv.importVariables('calculate.%s.variables'%kwargs['datavars'])
+                dv.defaultModule = kwargs['datavars']
+                dv.flIniFile()
+                cls.modifyDatavars(dv,kwargs['setvars'])
+            # созданием группы переменных из datavars согласно параметрам groups
+            for groupfunc in kwargs['groups']:
+                groupfunc(dv.addGroup)
+            # указание brief если нужно
+            if "brief" in kwargs:
+                dv.addBrief(next_label=str(kwargs['brief'].get('next',_('Next'))),
+                            image=kwargs['brief'].get('image',None))
+            return dv
+        return wrapper
+
+class WsdlBase:
+    """
+    Базовый класс для автосоздания методов по описанию methods
+    """
+    __metaclass__ = WsdlMeta
+
+def clearDataVars(func):
+    def wrapper(*args,**kwargs):
+        try:
+            return func(*args,**kwargs)
+        finally:
+            WsdlMeta.closeDataVars()
+    return wrapper
diff --git pym/core/server/func_metaclass.py pym/core/server/func_metaclass.py
index 1e2b867..7a983c0 100644
--- pym/core/server/func_metaclass.py
+++ pym/core/server/func_metaclass.py
@@ -16,8 +16,9 @@
 
 import importlib
 
-list_module = ["clean", "gen_pid",
-               "sid_pid_file", "gen_sid", "func", "api_types",]
+list_module = ["clean", "gen_pid", \
+               "sid_pid_file", "gen_sid", "func", "api_types", \
+               'system_update']
 
 imported_modules = []
 pack = "calculate.core.server"
diff --git pym/core/server/gen_pid.py pym/core/server/gen_pid.py
index 8c9eb31..2b313cf 100644
--- pym/core/server/gen_pid.py
+++ pym/core/server/gen_pid.py
@@ -29,7 +29,6 @@ class ProcessStatus:
     FailedFinished = 2
     NotFound = 3
     Paused = 4
-    Question = 5
 
 class ProcessMode:
     CoreDaemon = "core"
@@ -37,8 +36,7 @@ class ProcessMode:
 
 
 def search_worked_process(method_name, clVars,
-                          statuses=(ProcessStatus.Worked,
-                                    ProcessStatus.Question)):
+                          statuses=(ProcessStatus.Worked,)):
     """
     Найти все работающие процессы
 
@@ -60,8 +58,7 @@ def search_worked_process(method_name, clVars,
 
     return list(generator())
 
-def get_pid_info(clVars, statuses=(ProcessStatus.Worked,
-                                   ProcessStatus.Question)):
+def get_pid_info(clVars, statuses=(ProcessStatus.Worked,)):
     """
     Получить информацию о процессах
     """
diff --git pym/core/server/loaded_methods.py pym/core/server/loaded_methods.py
index 7002480..78e8bc8 100644
--- pym/core/server/loaded_methods.py
+++ pym/core/server/loaded_methods.py
@@ -15,10 +15,10 @@
 #  limitations under the License.
 
 class LoadedMethods:
+    conMethods = {}
+    guiMethods = {}
     rightsMethods = {}
 
-    methods_info = []
-
     # add needed rights for call method
     @classmethod
     def check_permissions(cls, add_right=[]):
@@ -30,18 +30,22 @@ class LoadedMethods:
     # add needed rights for call method
     @classmethod
     def core_method(cls, gui=False, category=None, title=None, image=None, \
-                    command=None, rights=[], user=False, method_type="method"):
+                    command=None, rights=[], user=False):
         def wrapper(function):
-            cls.methods_info.append({
-                'name':function.__name__,
-                'category': category,
-                'title': title,
-                'icon': image,
-                'command': command,
-                'type':method_type,
-                'user': user,
-                'gui': gui
-            })
+            if gui:
+                if not category in cls.guiMethods.keys():
+                    cls.guiMethods[category] = []
+                cls.guiMethods[category].append(function.__name__)
+                cls.guiMethods[category].append(title)
+                cls.guiMethods[category].append(image)
+
+            if command:
+                if not command in cls.conMethods.keys():
+                    cls.conMethods[command] = []
+                cls.conMethods[command].append(function.__name__)
+                cls.conMethods[command].append(user)
+                if title:
+                    cls.conMethods[command].append(title)
 
             if rights:
                 cls.rightsMethods[function.__name__] = rights
diff --git pym/core/server/local_call.py pym/core/server/local_call.py
index 23ef163..964d134 100644
--- pym/core/server/local_call.py
+++ pym/core/server/local_call.py
@@ -16,8 +16,11 @@
 import pickle
 
 import sys
+import termios
 import os
 from os import path
+from fcntl import ioctl
+from array import array
 import threading
 
 from calculate.lib.utils.colortext import get_terminal_print
@@ -32,122 +35,21 @@ from calculate.lib.utils.files import makeDirectory
 from calculate.core.result_viewer import ResultViewer
 from calculate.core.server.loaded_methods import LoadedMethods
 from calculate.core.result_viewer_gui import ProgressGui, ErrorGui, WarningGui
-from calculate.core.server.local_messaging_api import LocalMessagingAPI
 from gen_pid import ProcessStatus
 
-from methods_func import (get_method_argparser, collect_object,
-                          check_result_msg, get_param_pwd, _print,
-                          display_error)
+from methods_func import get_method_argparser, collect_object, \
+    check_result_msg, get_param_pwd, _print, display_error
 from api_types import ViewInfo
 from cert_cmd import parse
-from methods_func import GotErrorField
+from methods_func import getErrorOnParam, GotErrorField
 from func import shortTraceback, CommonMethods, CommonLink
 
 
 setLocalTranslate('cl_core3', sys.modules[__name__])
-from itertools import izip, ifilter
+from itertools import cycle, izip, ifilter
+import time
 
 
-class MethodCallStrategy(object):
-    """
-    Стратегия вызова метода
-    """
-    def startprocess(self, sid, func=None, func_args=(), **kw):
-        """
-        Запустить процесс с выполением задачи
-        """
-        pass
-
-    def get_messaging_api(self):
-        """
-        Получить объект реализующий API сообщений
-        """
-        pass
-
-
-class LocalCallStrategy(object):
-    """
-    Стратегия локального вызова
-    """
-    def __init__(self, dv, no_progress=False, gui_progress=False,
-                 gui_warning=False, no_questions=False):
-        self.no_progress = no_progress
-        self.gui_progress = gui_progress
-        self.gui_warning = gui_warning
-        self.no_questions = no_questions
-        self.dv = dv
-
-    def startprocess(self, sid, process_info, func=None, args_proc=(), **kw):
-        if "LANG" in os.environ:
-            cur_thread = threading.currentThread()
-            cur_thread.lang = os.environ["LANG"]
-        process_info.method_status = ProcessStatus.Worked
-        if func(*args_proc):
-            pass
-        return 0
-
-    def get_messaging_API(self):
-        result_viewer = LocalMessagingAPI()
-        if self.no_questions:
-            result_viewer.set_no_questions()
-        if self.no_progress:
-            result_viewer.set_no_progress()
-        if self.gui_progress:
-            result_viewer = ErrorGui(ProgressGui(result_viewer))
-        if self.gui_warning:
-            result_viewer = WarningGui(result_viewer)
-        return result_viewer
-
-    def get_process_API(self):
-        ebuild_phase = self.dv.Get('cl_ebuild_phase')
-        pids_path = self.dv.Get('core.cl_core_pids_path')
-        return ProcessLocalAPI(pids_path, ebuild_phase)
-
-
-class ProcessLocalAPI(object):
-    def __init__(self, pids_path, ebuild_phase):
-        self.method_name = None
-        self.method_status = None
-        self.ebuild_phase = ebuild_phase
-        self.pids_path = pids_path
-
-    def pause_process(self):
-        self.method_status = ProcessStatus.Paused
-        self.save_status()
-
-    def resume_process(self):
-        self.method_status = ProcessStatus.Worked
-        self.save_status()
-
-    def save_status(self):
-        """ write data in file """
-        if self.ebuild_phase:
-            return
-        from calculate.core.server.gen_pid import ProcessMode
-        if os.getuid():
-            return
-        pid = os.getpid()
-        # пропустить создание файла если идет сборка пакета
-        if not os.path.exists(self.pids_path):
-            makeDirectory(self.pids_path)
-        pid_file = path.join(self.pids_path, '%d.pid' % pid)
-        try:
-            with open(pid_file, 'w') as f:
-                d = {'name': self.method_name,
-                     'mode': ProcessMode.LocalCall,
-                     'os_pid': pid,
-                     'status': self.method_status}
-                pickle.dump(d, f)
-        except (IOError, OSError) as e:
-            print str(e)
-            print _("Failed to write the PID file %s!") % pid_file
-
-    def is_interactive(self):
-        """
-        Check interactive ability
-        """
-        return sys.stdin.isatty()
-
 class LocalCall(object):
     method_status = ProcessStatus.NotFound
 
@@ -241,7 +143,20 @@ class LocalCall(object):
             return sys.stdin.isatty()
 
 
-def local_method(metaclass, args, unknown_args, dv):
+def cout_progress(string=None):
+    try:
+        h, w = array('h', ioctl(sys.stderr, termios.TIOCGWINSZ, '\0' * 8))[:2]
+    except IOError:
+        return
+    sys.stdout.write('\r' + (' ' * (w)))
+    if string:
+        sys.stdout.write('\r' + string)
+    else:
+        sys.stdout.write('\r')
+    sys.stdout.flush()
+
+
+def local_method(metaclass, args, unknown_args):
     """
     Call method from metaclass, check method existing.
 
@@ -251,23 +166,21 @@ def local_method(metaclass, args, unknown_args, dv):
 
     sym_link = os.path.basename(sys.argv[0])
     if sym_link != 'cl-core':
-        for method_name in (x['name'] for x in LoadedMethods.methods_info
-                            if x['command'] == sym_link):
-            args.method = method_name
-            break
+        if sym_link in LoadedMethods.conMethods.keys():
+            args.method = LoadedMethods.conMethods[sym_link][0]
         else:
             _print(_("Method not found for %s") % sym_link)
             sys.exit(1)
 
     if args.list_methods:
-        for x in sorted((x for x in LoadedMethods.methods_info
-                         if x['command']), key=lambda x: x['name']):
-            print "%s - %s" % (x['name'], x['title'])
+        for k, v in sorted(LoadedMethods.conMethods.items(),
+                           key=lambda x: x[1]):
+            name, user, title = v
+            print "%s - %s" % (name, title)
         return 0
 
     colorPrint = color_print()
     metaObject = metaclass()
-    metaObject.method_calling = LocalCallStrategy(dv)
     method_name = args.method
     method_view_name = method_name + '_view'
     if args.method and args.help:
diff --git pym/core/server/local_messaging_api.py pym/core/server/local_messaging_api.py
deleted file mode 100644
index 1f42bbb..0000000
--- pym/core/server/local_messaging_api.py
+++ /dev/null
@@ -1,668 +0,0 @@
-#-*- coding: utf-8 -*-
-
-# Copyright 2011-2013 Calculate Ltd. http://www.calculate-linux.org
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-from itertools import cycle
-from calculate.core.server.messaging_api import MessagingAPI
-from calculate.lib.utils.colortext import get_terminal_print, Terminal, \
-    TextState, convert_xml_to_terminal, Print
-from calculate.lib.cl_progressbar import get_progress_bar
-import sys
-from calculate.lib.utils.files import getch, set_active_tty
-from calculate.lib.utils.text import tableReport
-import threading
-from calculate.lib.utils.tools import classificate
-
-Colors = TextState.Colors
-from calculate.lib.cl_lang import setLocalTranslate
-setLocalTranslate('cl_core3', sys.modules[__name__])
-
-
-class Spinner(threading.Thread):
-    def __init__(self, *args, **kwargs):
-        self.__halt = threading.Event()
-        self.__main_thread = threading.currentThread()
-        threading.Thread.__init__(self, *args, **kwargs)
-        self.start()
-
-    def run(self):
-        Terminal().cursor = False
-        try:
-            sys.stdout.write(" |")
-            for c in cycle('/-\|'):
-                sys.stdout.write('\b' + c)
-                sys.stdout.flush()
-                self.__halt.wait(0.2)
-                sys.stdout.flush()
-                if self.__halt.is_set():
-                    sys.stdout.write('\b\b  \b\b')
-                    return
-                if not self.__main_thread.is_alive():
-                    return
-        finally:
-            Terminal().cursor = True
-
-    def stop(self):
-        self.__halt.set()
-        self.join()
-
-
-class Table(tableReport):
-    def __init__(self, *args, **kwargs):
-        self.res = []
-        tableReport.__init__(self, *args, **kwargs)
-
-    def printFunc(self, s):
-        self.res.append(s)
-
-    def printTable(self):
-        self.setAutosize()
-        self.printReport(printRows=False)
-        return "".join(self.res)
-
-
-def printTable(data, header=None):
-    try:
-        return Table(None, header, data, colSpan=0).printTable()
-    except Exception as e:
-        print str(e)
-        raise
-
-
-class TaskState(object):
-    """
-    Текущее состояние вывода сообщений
-    """
-    def __init__(self, parent):
-        """
-        @type parent: LocalMessagingAPI
-        """
-        self.parent = parent
-
-    @property
-    def state(self):
-        return self.parent.task_state
-
-    def echo_on(f):
-        def wrapper(self, *args, **kw):
-            oldecho = self.parent.terminal_info.echo
-            self.parent.terminal_info.echo = True
-            try:
-                return f(self, *args, **kw)
-            finally:
-                self.parent.terminal_info.echo = oldecho
-        return wrapper
-
-    def process_tags(self, s):
-        """
-        Выполнить текстовое преобразование
-        """
-        s = s or ""
-        return convert_xml_to_terminal(s).replace("&nbsp;", " ")
-
-    def display_asterisk(self, color):
-        """
-        Отобразить маркер
-        """
-        self.parent.printer(" ")
-        self.parent.printer.foreground(color).bold("*")
-        self.parent.printer(" ")
-
-    def _right_indent(self, indent, width=-1):
-        """
-        Выполнить выравнивание от правого края
-        """
-        if width > 0:
-            self.parent.printer('\r')
-            self.parent.printer.right(width-indent)
-        else:
-            self.parent.printer(" ")
-
-    def _change_asterisk(self, color, width=-1):
-        if width > 0:
-            self.parent.printer('\r')
-            self.display_asterisk(color)
-
-    def dotting(self):
-        if self.parent.spinner:
-            self.parent.spinner.stop()
-        self.parent.printer(" ...")
-        self.parent.printer.flush()
-
-    def _print_result(self, text, color):
-        width = self.parent.terminal_info.width
-        self._change_asterisk(color, width)
-        self._right_indent(len(text)+4, width)
-        self.parent.printer.bold.foreground(TextState.Colors.BLUE)("[ ")
-        self.parent.printer.bold.foreground(color)(text)
-        self.parent.printer.bold.foreground(TextState.Colors.BLUE)(" ]")
-        self.parent.printer("\n")
-
-    def _print_ok(self):
-        self._print_result("ok", TextState.Colors.GREEN)
-
-    def _print_failed(self):
-        self._print_result("!!", TextState.Colors.RED)
-
-    def _print_skip(self):
-        self._print_result("skip", TextState.Colors.YELLOW)
-
-    def display_result(self, result):
-        func_map = {"skip": self._print_skip,
-                    False: self._print_failed}
-        func_map.get(result, self._print_ok)()
-        self.parent.printer.flush()
-
-    def startTask(self, message, progress, num):
-        pass
-
-    def endTask(self, result, progress_message=None):
-        pass
-
-    def breakTask(self):
-        pass
-
-    def printMessage(self, color, message):
-        for i, line in classificate(self.process_tags(message).split('\n')):
-            self.display_asterisk(color)
-            self.parent.printer(line)
-            if not i.last:
-                self.parent.printer('\n')
-        self.parent.printer.flush()
-
-    def printERROR(self, message):
-        self.printMessage(Colors.RED, message)
-
-    def printSUCCESS(self, message):
-        self.printMessage(Colors.GREEN, message)
-
-    def printWARNING(self, message):
-        self.printMessage(Colors.YELLOW, message)
-
-    def startGroup(self, message):
-        self.parent.printer.foreground(Colors.WHITE)(self.process_tags(message))
-        self.parent.printer('\n')
-
-    def endGroup(self):
-        pass
-
-    def beginFrame(self, message):
-        self.parent.terminal_info.echo = False
-
-    def endFrame(self):
-        self.parent.terminal_info.echo = True
-
-    def addProgress(self, message):
-        pass
-
-    def setProgress(self, percent, short_message, long_message):
-        pass
-
-    @echo_on
-    def askConfirm(self, message, default):
-        self.parent.printer("\n")
-        while True:
-            try:
-                _print = Print(output=self.parent.printer.output)
-                if default in "yes":
-                    yes_color, no_color = Colors.GREEN, Colors.LIGHT_RED
-                else:
-                    yes_color, no_color = Colors.LIGHT_RED, Colors.GREEN
-                yes = _print.foreground(yes_color)("Yes")
-                no = _print.foreground(no_color)("No")
-                white_message = _print.foreground(Colors.WHITE)(message)
-                ask = raw_input(white_message + ' (%s/%s): ' % (yes, no))
-            except (EOFError,KeyboardInterrupt):
-                ask = 'no'
-                print
-            if ask.lower() in ['n', 'no']:
-                return "no"
-            if ask.lower() in ['y', 'yes']:
-                return "yes"
-            if ask == '':
-                return default
-
-    def printPre(self, message):
-        self.parent.printer(self.process_tags(message))
-        self.parent.printer('\n')
-
-    def printDefault(self, message):
-        self.parent.printer(self.process_tags(message))
-        self.parent.printer('\n')
-
-    @echo_on
-    def askChoice(self, message, answers):
-        self.parent.printer("\n")
-        Colors = TextState.Colors
-        printer = self.parent.printer
-        _print = Print(output=printer.output)
-        # ability answer by first letter
-        FIRSTLETTER = 0
-        VALUE, COMMENT = 0, 1
-        answerByChar = map(lambda x: x[VALUE][FIRSTLETTER], answers)
-
-        if filter(lambda x: answerByChar.count(x) > 1, answerByChar):
-            use_getch = False
-            sa = slice(None)
-        else:
-            use_getch = True
-            sa = slice(1)
-        message = _print.foreground(Colors.WHITE)(message)
-        full_message = message + ' (%s): ' % \
-                       ("/".join(map(lambda x: \
-                                         "%s[%s]" % (x[COMMENT], x[VALUE][sa]),
-                                     answers)))
-        while True:
-            CTRC_C = chr(3)
-            if use_getch:
-                printer(full_message)
-                ask = getch()
-                printer("\n")
-                if ask in (CTRC_C,""):
-                    raise KeyboardInterrupt
-            else:
-                try:
-                    ask = raw_input(full_message)
-                except (EOFError,KeyboardInterrupt):
-                    printer("\n")
-                    raise KeyboardInterrupt
-            ask = ask.lower()
-            like_answers = filter(lambda x: x[VALUE].startswith(ask),
-                                  answers)
-            if not like_answers:
-                self.state.printERROR(_('The answer is uncertain'))
-                continue
-            if len(like_answers) == 1:
-                return like_answers[VALUE][FIRSTLETTER]
-            else:
-                self.state.printERROR(_('Ambiguous answer:') +
-                                      ",".join(map(lambda x: x[COMMENT],
-                                                   like_answers)))
-
-    @echo_on
-    def askQuestion(self, message):
-        self.parent.printer("\n")
-        return raw_input(message + _(":"))
-
-    def askPassword(self, message, twice):
-        from calculate.lib.utils.common import getpass
-        if self.parent.terminal_info.is_boot_console():
-            set_active_tty(1)
-
-        text1 = _("%s: ") % message
-        if not twice:
-            return getpass.getpass(text1)
-        text2 = _('Repeat: ')
-        pass1 = 'password'
-        pass2 = 'repeat'
-        try:
-            while pass1 != pass2:
-                pass1 = getpass.getpass(text1)
-                pass2 = getpass.getpass(text2)
-                if pass1 != pass2:
-                    self.state.printERROR(_('Passwords do not match'))
-        except KeyboardInterrupt:
-            return None
-        passwd = pass1 if (pass1 and pass1 == pass2) else None
-        return passwd
-
-    def printTable(self, table_name, head, body):
-        self.state.printSUCCESS(message=table_name)
-        self.parent.printer(printTable(body, head))
-
-
-class CleanState(TaskState):
-    """
-    Ожидается вывод
-    """
-    def startTask(self, message, progress, num):
-        self.printMessage(Colors.GREEN, message)
-        self.parent.spinner = Spinner()
-        self.parent.set_state('start')
-        if progress:
-            self.parent.add_progress()
-
-    def printERROR(self, message):
-        super(CleanState, self).printERROR(message)
-        self.parent.printer('\n')
-
-    def printSUCCESS(self, message):
-        super(CleanState, self).printSUCCESS(message)
-        self.parent.printer('\n')
-
-    def printWARNING(self, message):
-        super(CleanState, self).printWARNING(message)
-        self.parent.printer('\n')
-
-
-class CleanStateNoProgress(CleanState):
-    """
-    ... без отображения прогрессов
-    """
-    def startTask(self, message, progress, num):
-        self.display_asterisk(Colors.GREEN)
-        self.parent.printer(message)
-        self.dotting()
-        self.parent.set_state('start')
-
-
-class StartState(TaskState):
-    """
-    Выполняется задача (отображается spinner)
-    """
-    def startTask(self, message, progress, num):
-        self.parent.end_task(True)
-        self.parent.start_task(message, progress, num)
-
-    def endTask(self, result, progress_message=None):
-        self.dotting()
-        self.parent.set_state('clean')
-        self.display_result(result)
-
-    def breakTask(self):
-        self.dotting()
-        self.parent.set_state('clean')
-        self.parent.printer('\n')
-
-    def printERROR(self, message):
-        self.dotting()
-        self.parent.printer('\n')
-        self.parent.set_state('clean')
-        self.state.printERROR(message)
-
-    def printSUCCESS(self, message):
-        self.dotting()
-        self.parent.set_state('breaked')
-        self.state.printSUCCESS(message)
-
-    def printWARNING(self, message):
-        self.dotting()
-        self.parent.set_state('breaked')
-        self.state.printWARNING(message)
-
-    def startGroup(self, message):
-        self.state.endTask(True)
-        self.state.startGroup(message)
-
-    def endGroup(self):
-        self.state.endTask(True)
-        self.state.endGroup()
-
-    def beginFrame(self, message):
-        self.state.endTask(True)
-        self.state.beginFrame(message)
-
-    def endFrame(self):
-        self.state.endTask(True)
-        self.state.endFrame()
-
-    def addProgress(self, message):
-        self.parent.set_state("pre-progress")
-        self.state.addProgress(message)
-
-    def printPre(self, message):
-        self.parent.endTask(True)
-        self.state.printPre(message)
-
-    def printDefault(self, message):
-        self.state.endTask(True)
-        self.state.printDefault(message)
-
-    def askChoice(self, message, answers):
-        self.breakTask()
-        return self.state.askChoice(message, answers)
-
-    def askQuestion(self, message):
-        self.breakTask()
-        return self.state.askQuestion(message)
-
-    def askPassword(self, message, twice):
-        self.breakTask()
-        return self.state.askPassword(message, twice)
-
-    def askConfirm(self, message, default):
-        self.breakTask()
-        return self.state.askConfirm(message, default)
-
-    def printTable(self, table_name, head, body):
-        self.breakTask()
-        self.state.printTable(table_name, head, body)
-
-
-class StartStateNoProgress(StartState):
-    """
-    ... без прогресса
-    """
-    def startTask(self, message, progress, num):
-        self.parent.endTask(True)
-        self.parent.startTask(message, progress, num)
-
-    def endTask(self, result, progress_message=None):
-        self.parent.set_state('clean')
-        self.display_result(result)
-
-    def breakTask(self):
-        self.parent.printer('\n')
-
-    def printERROR(self, message):
-        self.breakTask()
-        self.parent.set_state('clean')
-        self.state.printERROR(message)
-
-    def printSUCCESS(self, message):
-        self.breakTask()
-        self.parent.set_state('clean')
-        self.state.printSUCCESS(message)
-
-    def printWARNING(self, message):
-        self.breakTask()
-        self.parent.set_state('clean')
-        self.state.printWARNING(message)
-
-    def addProgress(self, message):
-        pass
-
-
-class BreakedState(StartState):
-    """
-    Во время выполнения задачи выведено сообщение
-    """
-    def stop_spinner_newline(self):
-        self.parent.spinner.stop()
-        self.parent.printer('\n')
-
-    def startTask(self, message, progress, num):
-        self.state.endTask(True)
-        self.state.startTask(message, progress, num)
-
-    def breakTask(self):
-        self.stop_spinner_newline()
-        self.parent.set_state('clean')
-
-    def endTask(self, result, progress_message=None):
-        self.breakTask()
-
-    def printERROR(self, message):
-        self.parent.endTask(True)
-        self.state.printERROR(message)
-
-    def printSUCCESS(self, message):
-        self.stop_spinner_newline()
-        TaskState.printSUCCESS(self, message)
-        self.parent.spinner = Spinner()
-
-    def printWARNING(self, message):
-        self.stop_spinner_newline()
-        TaskState.printWARNING(self, message)
-        self.parent.spinner = Spinner()
-
-
-class PreProgressState(StartState):
-    """
-    Задача запрошена как с прогрессом но проценты еще не обрабатывались
-    """
-    def addProgress(self, message):
-        pass
-
-    def setProgress(self, percent, short_message, long_message):
-        self.parent.set_state("progress")
-        self.dotting()
-        self.parent.printer("\n")
-        self.parent.add_progressbar()
-        self.parent.terminal_info.cursor = False
-        self.state.setProgress(percent, short_message, long_message)
-
-
-class ProgressState(StartState):
-    """
-    Отображается progressbar
-    """
-    def finish_and_clean(self):
-        self.parent.printer('\r')
-        self.parent.printer.flush()
-        self.parent.progress.finish()
-        self.parent.terminal_info.cursor = True
-        self.parent.set_progressbar(None)
-        self.parent.printer.up(1).clear_line("")
-        self.parent.printer.up(1)("")
-
-    def setProgress(self, percent, short_message, long_message):
-        if 0 < percent > 100:
-            self.breakTask()
-        else:
-            self.parent.progress.update(percent)
-
-    def breakTask(self):
-        self.finish_and_clean()
-        self.parent.set_state('clean')
-        self.parent.printer('\n')
-
-    def endTask(self, result, progress_message=None):
-        self.finish_and_clean()
-        self.parent.set_state('clean')
-        self.display_result(result)
-
-    def printERROR(self, message):
-        self.finish_and_clean()
-        self.parent.printer.down(1)("")
-        self.parent.set_state('clean')
-        self.state.printERROR(message)
-
-    def printSUCCESS(self, message):
-        self.finish_and_clean()
-        self.parent.set_state('breaked')
-        self.state.printSUCCESS(message)
-
-    def printWARNING(self, message):
-        self.finish_and_clean()
-        self.parent.set_state('breaked')
-        self.state.printWARNING(message)
-
-
-class LocalMessagingAPI(MessagingAPI):
-    """
-    Просмотрщик результатов
-    """
-    def __init__(self):
-        self.printer = \
-            get_terminal_print(sys.stdout)
-        self.terminal_info = Terminal()
-        self.states = {'clean': CleanState(self),
-                       'breaked': BreakedState(self),
-                       'pre-progress': PreProgressState(self),
-                       'progress': ProgressState(self),
-                       'start': StartState(self)}
-        self.task_state = self.states['clean']
-        self.spinner = None
-        self.progress = None
-        self.no_questions = False
-
-    def set_no_progress(self):
-        self.states = {'clean': CleanStateNoProgress(self),
-                       'start': StartStateNoProgress(self)}
-        self.set_state('clean')
-
-    def set_no_questions(self):
-        self.no_questions = True
-
-    def set_state(self, state):
-        self.task_state = self.states[state]
-
-    def add_progressbar(self):
-        self.set_progressbar(get_progress_bar())
-
-    def set_progressbar(self, pb):
-        self.progress = pb
-
-    def end_task(self, result=None, progress_message=None):
-        self.task_state.endTask(result, progress_message)
-
-    def start_task(self, message, progress=False, num=1):
-        self.task_state.startTask(message, progress, num)
-
-    def print_error(self, message, only_show=None):
-        if only_show != 'gui':
-            self.task_state.printERROR(message)
-
-    def print_success(self, message, only_show=None):
-        if only_show != 'gui':
-            self.task_state.printSUCCESS(message)
-
-    def print_warning(self, message, only_show=None):
-        if only_show != 'gui':
-            self.task_state.printWARNING(message)
-
-    def start_group(self, message):
-        self.task_state.startGroup(message)
-
-    def end_group(self):
-        self.task_state.endGroup()
-
-    def begin_frame(self, message=None):
-        self.task_state.beginFrame(message)
-
-    def end_frame(self):
-        self.task_state.endFrame()
-
-    def add_progress(self, message=None):
-        self.task_state.addProgress(message)
-
-    def set_progress(self, percent, short_message=None, long_message=None):
-        self.task_state.setProgress(percent, short_message, long_message)
-
-    def print_pre(self, message, only_show=None):
-        if only_show != 'gui':
-            self.task_state.printPre(message)
-
-    def print_default(self, message='', only_show=None):
-        if only_show != 'gui':
-            self.task_state.printDefault(message)
-
-    def ask_confirm(self, message, default="yes"):
-        if self.no_questions:
-            return default
-        return self.task_state.askConfirm(message, default)
-
-    def ask_choice(self, message, answers=(("yes", "Yes"), ("no", "No"))):
-        return self.task_state.askChoice(message, answers)
-
-    def ask_password(self, message, twice=False):
-        return self.task_state.askPassword(message, twice)
-
-    def ask_question(self, message):
-        return self.task_state.askQuestion(message)
-
-    def print_table(self, table_name, head, body, fields=None,
-                    on_click=None, add_action=None):
-        self.task_state.printTable(table_name, head, body)
diff --git pym/core/server/messaging_api.py pym/core/server/messaging_api.py
deleted file mode 100644
index a99ceb7..0000000
--- pym/core/server/messaging_api.py
+++ /dev/null
@@ -1,231 +0,0 @@
-#-*- coding: utf-8 -*-
-
-# Copyright 2014 Calculate Ltd. http://www.calculate-linux.org
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-
-from abc import ABCMeta, abstractmethod
-
-class MessagingAPI(object):
-    __metaclass__ = ABCMeta
-
-    @abstractmethod
-    def end_task(self, result=None, progress_message=None):
-        """
-        Задача завершилась
-        :param result:
-        :param progress_message:
-        :return:
-        """
-
-    @abstractmethod
-    def start_task(self, message, progress=False, num=1):
-        """
-        Запущена задача
-        :param message:
-        :param progress:
-        :param num:
-        :return:
-        """
-
-    @abstractmethod
-    def print_error(self, message, only_show=None):
-        """
-        Вывести сообщение с ошибкой
-        :param message:
-        :param only_show:
-        :return:
-        """
-
-    @abstractmethod
-    def print_success(self, message, only_show=None):
-        """
-        Вывести обычное сообщение
-        :param message:
-        :param only_show:
-        :return:
-        """
-
-    @abstractmethod
-    def print_warning(self, message, only_show=None):
-        """
-        Вывести предупреждающее сообщение
-        :param message:
-        :param only_show:
-        :return:
-        """
-
-    @abstractmethod
-    def start_group(self, message):
-        """
-        Началась группа однотипных задача
-        :param message:
-        :return:
-        """
-
-    @abstractmethod
-    def end_group(self):
-        """
-        Закончилась группа однотипных задач
-        :return:
-        """
-
-    @abstractmethod
-    def begin_frame(self, message=None):
-        """
-        Начало фрейма
-        :param message:
-        :return:
-        """
-
-    @abstractmethod
-    def end_frame(self):
-        """
-        Конец фрейма
-        :return:
-        """
-
-    @abstractmethod
-    def add_progress(self, message=None):
-        """
-        Необходимо отобразить прогрессбар текущей задачи
-        :param message:
-        :return:
-        """
-
-    @abstractmethod
-    def set_progress(self, percent, short_message=None, long_message=None):
-        """
-        Установка процента выполнения задачи
-        :param percent:
-        :param short_message:
-        :param long_message:
-        :return:
-        """
-
-    @abstractmethod
-    def print_pre(self, message, only_show=None):
-        """
-        Вывести неформатированный текст
-        :param message:
-        :param only_show:
-        :return:
-        """
-
-    def print_default(self, message='', only_show=None):
-        """
-        Заглушка для совместимости
-        """
-        self.print_pre(message, only_show)
-
-    @abstractmethod
-    def ask_confirm(self, message, default="yes"):
-        """
-        Запросить у пользователя подтверждения действия
-        :param message:
-        :param default:
-        :return:
-        """
-
-    @abstractmethod
-    def ask_choice(self, message, answers=(("yes", "Yes"), ("no", "No"))):
-        """
-        Предоставить пользователю выбор действия
-        :param message:
-        :param answers:
-        :return:
-        """
-
-    @abstractmethod
-    def ask_password(self, message, twice=False):
-        """
-        Запросить у пользователя пароль
-        :param message:
-        :param twice:
-        :return:
-        """
-
-    @abstractmethod
-    def ask_question(self, message):
-        """
-        Задать пользователю вопрос
-        :param message:
-        :return:
-        """
-
-    @abstractmethod
-    def print_table(self, table_name, head, body, fields=None,
-                    on_click=None, add_action=None):
-        """
-        Вывести таблицу
-        :param table_name:
-        :param head:
-        :param body:
-        :param fields:
-        :param on_click:
-        :param add_action:
-        :return:
-        """
-
-class CoreAPI(MessagingAPI):
-    def ask_choice(self, message, answers=(("yes", "Yes"), ("no", "No"))):
-        pass
-
-    def end_group(self):
-        pass
-
-    def end_task(self, result=None, progress_message=None):
-        pass
-
-    def print_warning(self, message, only_show=None):
-        pass
-
-    def print_pre(self, message, only_show=None):
-        pass
-
-    def end_frame(self):
-        pass
-
-    def ask_question(self, message):
-        pass
-
-    def start_task(self, message, progress=False, num=1):
-        pass
-
-    def print_error(self, message, only_show=None):
-        pass
-
-    def print_success(self, message, only_show=None):
-        pass
-
-    def set_progress(self, percent, short_message=None, long_message=None):
-        pass
-
-    def ask_confirm(self, message, default="yes"):
-        pass
-
-    def begin_frame(self, message=None):
-        pass
-
-    def ask_password(self, message, twice=False):
-        pass
-
-    def print_table(self, table_name, head, body, fields=None, on_click=None,
-                    add_action=None):
-        pass
-
-    def start_group(self, message):
-        pass
-
-    def add_progress(self, message=None):
-        pass
diff --git pym/core/server/result_viewer_gui.py pym/core/server/result_viewer_gui.py
deleted file mode 100644
index ce35538..0000000
--- pym/core/server/result_viewer_gui.py
+++ /dev/null
@@ -1,123 +0,0 @@
-#-*- coding: utf-8 -*-
-
-# Copyright 2011-2013 Calculate Ltd. http://www.calculate-linux.org
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-import sys
-
-from calculate.lib.cl_progressbar import get_progress_bar, get_message_box
-from calculate.lib.utils.colortext import TextState
-
-from core.server.local_messaging_api import PreProgressState, ProgressState
-
-
-Colors = TextState.Colors
-from calculate.lib.cl_lang import setLocalTranslate
-setLocalTranslate('cl_core3', sys.modules[__name__])
-
-
-class PreProgressStateGui(PreProgressState):
-    """
-    Задача запрошена как с прогрессом но проценты еще не обрабатывались
-    """
-    def addProgress(self, message):
-        self.dotting()
-        self.parent.printer("\n")
-        self.parent.add_progressbar()
-        self.parent.set_state("progress")
-
-
-class ProgressStateGui(ProgressState):
-    """
-    Отображение для gui прогресса
-    """
-    def finish_and_clean(self):
-        self.parent.progress.finish()
-        self.parent.printer.up(1)("")
-        self.parent.set_progressbar(None)
-
-class ResultViewerDecorator(object):
-    def __init__(self, rv):
-        self.rv = rv
-        for v in self.rv.states.values():
-            v.parent = self
-
-    def __getattr__(self, item):
-        return getattr(self.rv, item)
-
-
-class ProgressGui(ResultViewerDecorator):
-    """
-    Отображение прогресса в Qt диалогах
-    """
-    def __init__(self, rv):
-        super(ProgressGui, self).__init__(rv)
-        self.rv.states['pre-progress'] = PreProgressStateGui(self)
-        self.rv.states['progress'] = ProgressStateGui(self)
-        self.progress_title = ""
-
-    def add_progressbar(self):
-        self.set_progressbar(get_progress_bar("gui", self.progress_title))
-
-    def startTask(self, message, progress=False, num=1):
-        self.rv.startTask(message, progress, num)
-        self.progress_title = message
-
-
-class ErrorGui(ResultViewerDecorator):
-    """
-    Отображение ошибок через gui
-    """
-    def __init__(self, rv):
-        super(ErrorGui, self).__init__(rv)
-        self.messages = []
-
-    def show_messages(self):
-        get_message_box().critical("\n".join(self.messages).decode('utf-8'))
-
-    def printERROR(self, message, onlyShow=None):
-        self.rv.printERROR(message, onlyShow)
-        if onlyShow != 'gui':
-            if message:
-                self.messages.append(message)
-
-    def endFrame(self):
-        self.rv.task_state.endFrame()
-        if self.messages:
-            self.show_messages()
-
-
-class WarningGui(ResultViewerDecorator):
-    """
-    Отображение предупреждений через gui
-    """
-    def __init__(self, rv):
-        super(WarningGui, self).__init__(rv)
-        self.warnings = []
-
-    def show_messages(self):
-        get_message_box().warning("\n".join(self.warnings).decode('utf-8'))
-
-    def printWARNING(self, message, onlyShow=None):
-        self.rv.printWARNING(message, onlyShow)
-        if onlyShow != 'gui':
-            if message:
-                self.warnings.append(message)
-
-    def endFrame(self):
-        self.rv.task_state.endFrame()
-        if not self.messages and self.warnings:
-            self.show_messages()
-        elif self.messages:
-            self.messages.extend(self.warnings)
-            self.rv.show_messages()
diff --git pym/core/server/server_class.py pym/core/server/server_class.py
index c424ddd..109ee7b 100644
--- pym/core/server/server_class.py
+++ pym/core/server/server_class.py
@@ -14,7 +14,7 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
-from soaplib.wsgi import Application, HTTP_200, HTTP_405, HTTP_500
+from soaplib.wsgi import Application
 import re
 import logging, os, OpenSSL
 logger = logging.getLogger(__name__)
@@ -29,15 +29,18 @@ from loaded_methods import LoadedMethods
 # for OpenSSLAdapter
 from cherrypy.wsgiserver.ssl_pyopenssl import pyOpenSSLAdapter
 
+HTTP_500 = '500 Internal server error'
+HTTP_200 = '200 OK'
+HTTP_405 = '405 Method Not Allowed'
 HTTP_403 = '403 Forbidden'
-not_log_list = ['post_server_request', 'post_client_request', 'del_sid',
-                'get_server_cert', 'get_client_cert', 'get_entire_frame',
-                'get_crl', 'get_server_host_name', 'get_ca', 'get_table',
-                'post_cert', 'post_sid', 'active_client', 'list_pid',
+not_log_list = ['post_server_request', 'post_client_request', 'del_sid', \
+                'get_server_cert', 'get_client_cert', 'get_entire_frame', \
+                'get_crl', 'get_server_host_name', 'get_ca', 'get_table', \
+                'post_cert', 'post_sid', 'active_client', 'list_pid', \
                 'get_methods', 'get_frame', 'get_progress', 'pid_info']
 
 class ClApplication(Application):
-    def __init__(self, services, tns, name=None, _with_partnerlink=False,
+    def __init__(self, services, tns, name=None, _with_partnerlink=False, \
                  log=None):
         '''
         @param A ServiceBase subclass that defines the exposed services.
diff --git pym/core/server/system_update.py pym/core/server/system_update.py
new file mode 100644
index 0000000..f3570d9
--- /dev/null
+++ pym/core/server/system_update.py
@@ -0,0 +1,89 @@
+#-*- coding: utf-8 -*-
+
+# Copyright 2010-2013 Calculate Ltd. http://www.calculate-linux.org
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+import sys, time
+
+from soaplib.serializers.primitive import String, Integer, Boolean
+from soaplib.serializers.clazz import Array, ClassSerializer
+from soaplib.service import rpc
+
+from calculate.core.server.api_types import ReturnedMessage
+from calculate.lib.cl_lang import setLocalTranslate
+setLocalTranslate('cl_core3',sys.modules[__name__])
+
+class SU (ClassSerializer):
+    name = String
+    times = Integer
+    boolvariable = Boolean
+    boolvariable2 = Boolean
+    radiovariable = String
+    radiovariable2 = String
+    combovariable = String
+    combovariable2 = String
+    comboEdit1 = String
+    comboEdit2 = String
+    multichoice_add = Array(String)
+    multichoice = Array(String)
+    Partition_table = Array(Array(String))
+    Partition_table2 = Array(Array(String))
+
+    Steps = Array(Array(String))
+    isopath = Array(String)
+
+    comboLang = String
+
+    # for check parameters without call method
+    CheckOnly = Boolean
+
+class CoreWsdl:
+    def system_update_meth (self) :
+        try:
+            results = []
+            self.writeFile()
+            # ask password
+            self.startTask("System Update", True)
+
+            # Учёт процесса выполнения
+            perc = 0
+            while self.getProgress() < 100:
+                time.sleep(1.6)
+                perc += 10
+                # Увеличение процента выполнения процесса
+                self.setProgress (perc)
+
+            #self.printERROR ('No internet connected!')
+            self.endTask(_("System updated!"))
+
+            #self.endFrame()
+            # necessary for correct complete the process
+            return True
+        # Обработка сигнала прерывания работы процесса
+        except KeyboardInterrupt:
+            # Необходимо передать Fasle для сохранения данных о процессе
+            return False
+        except:
+            return False
+
+    @rpc(Integer, _returns = Array(ReturnedMessage))
+    def system_update_tray(self, sid):
+        system_update_meth = type \
+                        ("CommonInstall",(self.Common, CoreWsdl, object), {})
+        pid = self.startprocess(sid, target=system_update_meth, \
+                                        method="system_update_meth",\
+                                        method_name='System Update', \
+                                        args_proc = ())
+        returnmess = ReturnedMessage(type = 'pid', message = pid)
+        return [returnmess]
diff --git pym/core/server/task_set.py pym/core/server/task_set.py
deleted file mode 100644
index 6095175..0000000
--- pym/core/server/task_set.py
+++ /dev/null
@@ -1,132 +0,0 @@
-#-*- coding: utf-8 -*-
-
-# Copyright 2014 Calculate Ltd. http://www.calculate-linux.org
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-
-from messaging_api import MessagingAPI
-from collections import Mapping
-
-
-class MessagingSupport(object):
-    """
-    Объект поддерживающий модель сообщений
-    """
-    def __init__(self, messaging_api):
-        """
-        @type messaging_api: MessagingAPI
-        """
-        self.messaging = messaging_api
-
-    def askChoice(self, message, answers=(("yes", "Yes"), ("no", "No"))):
-        return self.messaging.ask_choice(message, answers)
-
-    def endGroup(self):
-        return self.messaging.end_group()
-
-    def endTask(self, result=None, progress_message=None):
-        return self.messaging.end_task(result, progress_message)
-
-    def printDefault(self, message='', onlyShow=None):
-        return self.messaging.print_default(message, onlyShow)
-
-    def printWARNING(self, message, onlyShow=None):
-        return self.messaging.print_warning(message, onlyShow)
-
-    def printPre(self, message, onlyShow=None):
-        return self.messaging.print_pre(message, onlyShow)
-
-    def endFrame(self):
-        return self.messaging.end_frame()
-
-    def startTask(self, message, progress=False, num=1):
-        return self.messaging.start_task(message, progress, num)
-
-    def askQuestion(self, message):
-        return self.messaging.ask_question(message)
-
-    def printERROR(self, message, onlyShow=None):
-        return self.messaging.print_error(message, onlyShow)
-
-    def setProgress(self, percent, short_message=None, long_message=None):
-        return self.setProgress(percent, short_message, long_message)
-
-    def printSUCCESS(self, message, onlyShow=None):
-        return self.messaging.print_success(message, onlyShow)
-
-    def askConfirm(self, message, default="yes"):
-        return self.messaging.ask_confirm(message, default)
-
-    def askPassword(self, message, twice=False):
-        return self.messaging.ask_password(message, twice)
-
-    def beginFrame(self, message=None):
-        return self.messaging.begin_frame(message)
-
-    def startGroup(self, message):
-        return self.messaging.start_group(message)
-
-    def printTable(self, table_name, head, body, fields=None, onClick=None,
-                   addAction=None):
-        return self.messaging.print_table(table_name, head, body, fields,
-                                          onClick,
-                                          addAction)
-
-    def addProgress(self, message=None):
-        return self.messaging.add_progress(message)
-
-
-class TaskSet(MessagingSupport):
-    """
-    Набор операций для выполнения действий
-    """
-
-    def __init__(self, messaging_api, process_api, dv, parent):
-        """
-            @type messaging_api: MessagingAPI
-            """
-        super(TaskSet, self).__init__(messaging_api)
-        self.clVars = dv
-        self.parent = parent
-        self.process = process_api
-
-    def init(self):
-        pass
-
-
-class TaskSetAggregation(Mapping):
-    """
-    Соединение наборов операций
-    """
-    def __init__(self, messaging_api, process_api, dv, task_sets={}):
-        """
-        @type messaging_api: MessagingAPI
-        @type dv: DataVars
-        @type task_sets: [str, type of TaskSet]
-        """
-        self.messaging = messaging_api
-        self.dv = dv
-        self.tasks = {}
-        for name, task_set in task_sets.items():
-            ts = task_set(messaging_api, process_api, dv, self)
-            ts.init()
-            self.tasks[name] = ts
-
-    def __getitem__(self, item):
-        return self.tasks[item]
-
-    def __iter__(self):
-        return iter(self.tasks)
-
-    def __len__(self):
-        return len(self.tasks)
diff --git pym/core/server/wsdl_api.py pym/core/server/wsdl_api.py
deleted file mode 100644
index 1a37cb0..0000000
--- pym/core/server/wsdl_api.py
+++ /dev/null
@@ -1,76 +0,0 @@
-#-*- coding: utf-8 -*-
-
-# Copyright 2014 Calculate Ltd. http://www.calculate-linux.org
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-
-#import importlib
-#
-#list_module = ["clean",
-#               "gen_pid",
-#               "sid_pid_file",
-#               "gen_sid",
-#               "func",
-#               "api_types"]
-#
-#imported_modules = []
-#pack = "calculate.core.server"
-#for module_name in list_module:
-#    imported_modules.append(importlib.import_module('%s.%s' \
-#                                                    %(pack, module_name)).CoreWsdl)
-#
-#imported_modules.append(object)
-#imported = tuple (imported_modules)
-#
-## create metaclass, including all methods server class
-#Func_MetaClass = type ("Func_MetaClass", (imported), {})
-#
-#print other_mod
-##try:
-#pack = "calculate.core.server"
-#import importlib
-#func_metaclass = importlib.import_module('%s.func_metaclass' %pack)
-#
-#other_mod.append(func_metaclass.Func_MetaClass)
-#
-#from calculate.core.server.baseClass import Basic
-#other_mod.append(Basic)
-#other_mod.append(object)
-#
-#class WsdlAPI(type):
-#    def initialization(cl_wsdl):
-#        """ find modules for further added in server class """
-#        cl_apis = []
-#        for pack in cl_wsdl:
-#            if pack:
-#                module_name = '%s.wsdl_%s'% (pack.replace("-","."),
-#                                             pack.rpartition("-")[2])
-#                import importlib
-#                cl_wsdl_core = importlib.import_module(module_name)
-#                try:
-#                    cl_apis.append (cl_wsdl_core.Wsdl)
-#                except ImportError:
-#                    sys.stderr.write(_("Unable to import %s")%module_name)
-#        return cl_apis
-#    def __new__(mcs, name, bases, attrs):
-#        #if "methods" in attrs:
-#        #    for method in attrs["methods"]:
-#        #        attrs[method['method_name']] = {
-#        #            'method': mcs.caller_constructor,
-#        #            'directory': mcs.directory_constructor
-#        #        }.get(method.get('type', 'method'))(**method)
-#        #        attrs["%s_vars" % method['method_name']] = \
-#        #            mcs.datavars_constructor(**method)
-#        #        attrs["%s_view" % method['method_name']] = \
-#        #            mcs.view_constructor(**method)
-#        #return type.__new__(mcs, name, bases, attrs)
diff --git pym/core/server/wsdl_meta.py pym/core/server/wsdl_meta.py
deleted file mode 100644
index 230f871..0000000
--- pym/core/server/wsdl_meta.py
+++ /dev/null
@@ -1,282 +0,0 @@
-#-*- coding: utf-8 -*-
-
-# Copyright 2014 Calculate Ltd. http://www.calculate-linux.org
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-
-import sys
-from calculate.lib.cl_lang import setLocalTranslate, getLazyLocalTranslate
-from calculate.lib.datavars import DataVarsError
-from itertools import *
-from calculate.lib.utils.tools import short_traceback
-
-from soaplib.serializers.primitive import String, Integer, Boolean
-from soaplib.serializers.clazz import Array
-from soaplib.service import rpc
-from calculate.core.server.api_types import (ReturnedMessage, CommonInfo,
-                                             GroupField, Field, ViewInfo,
-                                             ViewParams, MethodInfo)
-from calculate.lib.datavars import DataVars
-from loaded_methods import LoadedMethods
-
-_ = lambda x: x
-setLocalTranslate('cl_core3', sys.modules[__name__])
-__ = getLazyLocalTranslate(_)
-
-
-class WsdlMeta(type):
-    """
-    Метакласс для создания методов по атрибуту methdos
-    """
-    datavars = {}
-
-    def __new__(mcs, name, bases, attrs):
-        if "methods" in attrs:
-            for method in attrs["methods"]:
-                attrs[method['method_name']] = {
-                    'method': mcs.caller_constructor,
-                    'directory': mcs.directory_constructor
-                }.get(method.get('type', 'method'))(**method)
-                attrs["%s_vars" % method['method_name']] = \
-                    mcs.datavars_constructor(**method)
-                attrs["%s_view" % method['method_name']] = \
-                    mcs.view_constructor(**method)
-        return type.__new__(mcs, name, bases, attrs)
-
-    @classmethod
-    def close_datavars(mcs):
-        for dv in WsdlMeta.datavars.values():
-            dv.close()
-
-    @classmethod
-    def create_info_obj(mcs, **kwargs):
-        """
-        Создание передаваемой структуры данных для WSDL
-        """
-
-        def type_convert(s):
-            for k, v in {'bool': Boolean,
-                         'table': Array(Array(String)),
-                         'list': Array(String)}.items():
-                if k in s:
-                    return v
-            else:
-                return String
-
-        d = {}
-        dv_name = kwargs['datavars']
-        if dv_name in WsdlMeta.datavars:
-            dv = WsdlMeta.datavars[dv_name]
-        else:
-            dv = DataVars()
-            dv.importVariables()
-            dv.importVariables('calculate.%s.variables' % dv_name)
-            dv.defaultModule = dv_name
-            WsdlMeta.datavars[dv_name] = dv
-
-        def group(caption, normal=(), expert=(), **kwargs):
-            for v in chain(normal, expert):
-                d[v] = type_convert(dv.getInfo(v).type)
-
-        for gr in kwargs.get('groups', []):
-            gr(group)
-        if not "cl_page_count" in d:
-            d["CheckOnly"] = Boolean
-        return d
-
-    @classmethod
-    def caller_constructor(mcs, **kwargs):
-        """
-        Конструктор для создания метода-вызова для действия
-        """
-
-        def wrapper(self, sid, info):
-            # костыль для локализации install
-            callback_refresh = self.fixInstallLocalization \
-                if kwargs['method_name'] == 'install' else lambda *args: True
-            return self.callAction(sid, info, logicClass=kwargs['logic'],
-                                   actionClass=kwargs['action'],
-                                   method_name=kwargs['method_name'],
-                                   callbackRefresh=callback_refresh)
-
-        wrapper.func_name = kwargs['method_name']
-        func = LoadedMethods.core_method(category=kwargs.get('category', None),
-                                         title=kwargs['title'],
-                                         image=kwargs.get('image', None),
-                                         gui=kwargs.get('gui', False),
-                                         method_type='method',
-                                         user=kwargs.get('user', False),
-                                         command=kwargs.get('command', None),
-                                         rights=kwargs['rights'])(wrapper)
-        if "--start" in sys.argv:
-            info_obj = mcs.create_info_obj(**kwargs)
-            info_class = type("%sInfo" % kwargs["method_name"], (CommonInfo,),
-                              info_obj)
-            return rpc(Integer, info_class,
-                       _returns=Array(ReturnedMessage))(func)
-        else:
-            return func
-
-    @classmethod
-    def directory_constructor(mcs, **kwargs):
-        """
-        Конструктор для создания метода-списка действия
-        """
-
-        def wrapper(self, sid, info):
-            return self.callDirectory(sid, info, logicClass=kwargs['logic'],
-                                      method_name=kwargs['method_name'])
-
-        wrapper.func_name = kwargs['method_name']
-        func = LoadedMethods.core_method(category=kwargs.get('category', None),
-                                         title=kwargs['title'],
-                                         image=kwargs.get('image', None),
-                                         gui=kwargs.get('gui', False),
-                                         method_type='directory',
-                                         user=kwargs.get('user', False),
-                                         command=None,
-                                         rights=kwargs['rights'])(wrapper)
-        if "--start" in sys.argv:
-            info_obj = mcs.create_info_obj(**kwargs)
-            info_class = type("%sInfo" % kwargs["method_name"], (CommonInfo,),
-                              info_obj)
-            return rpc(Integer, info_class, _returns=Array(MethodInfo))(func)
-        else:
-            return func
-
-    @classmethod
-    def modify_datavars(mcs, dv, data):
-        """
-        Поменять значения в datavars согласно data
-        """
-        # установить заданные значения (!) принудительная установка
-        for k, v in data.items():
-            # если значение функция
-            if callable(v):
-                v = v(dv)
-            dv.Set(k.strip('!'), v, force=k.endswith('!'))
-
-    @staticmethod
-    def catch_except(*skip_exception):
-        class Wrapper:
-            def __init__(self, f):
-                self.f = f
-                self.func_name = f.func_name
-                self.func_code = f.func_code
-                self.__doc__ = f.__doc__
-                self.__name__ = f.__name__
-
-            def __call__(self, *args, **kwargs):
-                try:
-                    return self.f(*args, **kwargs)
-                except BaseException as e:
-                    view = ViewInfo(groups=[])
-                    group = GroupField(name=_("Error"), last=True)
-                    group.fields = []
-                    group.fields.append(Field(
-                        name="error",
-                        label=str(e),
-                        default='color:red;',
-                        element="error"))
-                    view.groups.append(group)
-                    if not any(isinstance(e, x) for x in skip_exception):
-                        print short_traceback(*sys.exc_info())
-                    return view
-
-        return Wrapper
-
-    @classmethod
-    def view_constructor(mcs, **kwargs):
-        """
-        Конструктор для создания метода-представления
-        """
-
-        def wrapper(self, sid, params):
-            dv = self.get_cache(sid, kwargs["method_name"], "vars")
-            lang_changed = False
-            if kwargs.get("groups", None):
-                def group(caption, normal=(), expert=(), **kwargs):
-                    if isinstance(normal, (unicode, str)):
-                        raise DataVarsError(_("Wrong normal varaiables list"))
-                    if isinstance(expert, (unicode, str)):
-                        raise DataVarsError(_("Wrong expert varaiables list"))
-
-                for gr in kwargs['groups']:
-                    gr(group)
-            if not dv:
-                dv = getattr(self, "%s_vars" % kwargs["method_name"])()
-                if hasattr(params, "clienttype"):
-                    if params.clienttype == 'gui' and "guivars" in kwargs:
-                        mcs.modify_datavars(dv, kwargs['guivars'])
-                    if params.clienttype != 'gui' and "consolevars" in kwargs:
-                        mcs.modify_datavars(dv, kwargs['consolevars'])
-            else:
-                # костыль для метода install, который меняет локализацию
-                # интрефейса в зависимости от выбранного параметра lang
-                if kwargs["method_name"] == 'install':
-                    lang_changed = self.fixInstallLocalization(sid, dv)
-                    lang = dv.Get('install.os_install_locale_lang')
-                    self.set_cache(sid, "install", "lang", lang, smart=False)
-                dv.processRefresh()
-            self.set_cache(sid, kwargs["method_name"], "vars", dv, smart=False)
-            if "brief" in kwargs and "name" in kwargs['brief']:
-                brief_label = str(kwargs['brief']['name'])
-            else:
-                brief_label = None
-            if kwargs.get("groups", None):
-                view = ViewInfo(dv, viewparams=params,
-                                has_brief="brief" in kwargs,
-                                allsteps=lang_changed,
-                                brief_label=brief_label)
-            else:
-                view = ViewInfo()
-            return view
-
-        wrapper.func_name = "%s_view" % kwargs['method_name']
-        return rpc(Integer, ViewParams, _returns=ViewInfo)(
-            mcs.catch_except(kwargs.get("native_error", ()))(wrapper))
-
-    @classmethod
-    def datavars_constructor(mcs, **kwargs):
-        """
-        Конструктор для создания метода описания параметров
-        """
-
-        def wrapper(self, dv=None):
-            if not dv:
-                dv = DataVars()
-                dv.importVariables()
-                dv.importVariables(
-                    'calculate.%s.variables' % kwargs['datavars'])
-                dv.defaultModule = kwargs['datavars']
-                dv.flIniFile()
-                if kwargs.get('setvars', None):
-                    mcs.modify_datavars(dv, kwargs['setvars'])
-            # созданием группы переменных из datavars согласно параметрам groups
-            for group_func in kwargs.get('groups', []):
-                group_func(dv.addGroup)
-            # указание brief если нужно
-            if "brief" in kwargs:
-                dv.addBrief(
-                    next_label=str(kwargs['brief'].get('next', _('Next'))),
-                    image=kwargs['brief'].get('image', None))
-            return dv
-
-        return wrapper
-
-
-class WsdlBase:
-    """
-    Базовый класс для автосоздания методов по описанию methods
-    """
-    __metaclass__ = WsdlMeta
diff --git pym/core/set_vars.py pym/core/set_vars.py
index 919e1ff..2f0861e 100644
--- pym/core/set_vars.py
+++ pym/core/set_vars.py
@@ -66,7 +66,6 @@ class Variables:
     def showVariables(self,showVal,filterVal,vardata):
         """
         Show variables by cl_variable_filter
-        showVal : --only-value
         """
         dv = self.clVars
         removeQuotes = lambda x: x if x != "''" else ""
@@ -85,11 +84,11 @@ class Variables:
                 typeVar = dv.getInfo(varname).type
                 val = dv.unserialize(typeVar,prevVal)
                 if index < len(val):
-                    self.printPre(removeQuotes(val[index]))
+                    self.printDefault(removeQuotes(val[index]))
                 else:
-                    self.printPre("")
+                    self.printDefault("")
             else:
-                self.printPre(removeQuotes(prevVal))
+                self.printDefault(removeQuotes(prevVal))
             return True
         filterFunc = \
             {'all':None,
diff --git pym/core/setup_package.py pym/core/setup_package.py
index 1003fcb..7316b7a 100644
--- pym/core/setup_package.py
+++ pym/core/setup_package.py
@@ -303,10 +303,10 @@ class UpdateConfigs(UpdateLogger):
                         pid.get("os_pid",'') != cur_pid)]
         if pid_list:
             _print = self.color_print
-            method_names = {x['name']:x['title'] for x in 
-                            LoadedMethods.methods_info}
+            method_names = {value[0]:value[2] for key,value in 
+                            LoadedMethods.conMethods.items()}
             self.printSUCCESS(
-                _("Calculate core is executing follow tasks now"))
+                _("Calculate core is executing the following tasks"))
             mult = _print.bold("*")
             for pid in pid_list:
                 name = pid['name']
