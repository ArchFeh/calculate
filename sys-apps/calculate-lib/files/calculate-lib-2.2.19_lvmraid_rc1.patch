diff --git pym/cl_fill.py pym/cl_fill.py
index a846970..6dfe11d 100644
--- pym/cl_fill.py
+++ pym/cl_fill.py
@@ -23,8 +23,9 @@ import cl_overriding
 from cl_vars_share import varsShare, clLocale
 from os.path import exists as pathexists
 from os import path
-from cl_utils import isMount, genpassword, getAvailableX11Drivers, \
-                     listDirectory,isPkgInstalled,lspci
+from cl_utils import isMount, genpassword, \
+                     getAvailableVideo, process, \
+                     listDirectory,isPkgInstalled,lspci, readLinesFile
 from utils import ip
 from encrypt import getHash
 
@@ -188,20 +189,19 @@ class fillVars(varsShare):
             if re.match("^\/dev\/[a-z]+.*$", rootparam):
                 return rootparam
             # check root set by uuid
-            uuidpath = '/dev/disk/by-uuid'
-            if os.access(uuidpath,os.R_OK):
-                uuidDevs = filter(path.islink,
-                              map(lambda x: path.join(uuidpath,x),
-                                  os.listdir(uuidpath)))
-                mapUuidDev = dict(map(lambda x:(path.basename(x),
-                                path.normpath(path.join(uuidpath,
-                                os.readlink(x)))), uuidDevs))
-            else:
-                mapUuidDev = {}
             if re.match("^UUID=.*$",rootparam):
-                uuid = rootparam[5:]
-                if uuid in mapUuidDev:
-                    return mapUuidDev[uuid]
+                uuid = rootparam[5:].strip("\"'")
+                blkidProcess = process('/sbin/blkid','-c','/dev/null','-U',
+                                    uuid)
+                if blkidProcess.success():
+                    return blkidProcess.read().strip()
+            # check root set by label
+            if re.match("^LABEL=.*$",rootparam):
+                uuid = rootparam[6:].strip("\"'")
+                blkidProcess = process('/sbin/blkid','-c','/dev/null','-L',
+                                    uuid)
+                if blkidProcess.success():
+                    return blkidProcess.read().strip()
         # get device mounted to root
         dfLines = self._runos("LANG=C df /")
         if not dfLines:
@@ -388,23 +388,25 @@ class fillVars(varsShare):
         xorg_conf = '/etc/X11/xorg.conf'
         # Try analize Xorg.{DISPLAY}.log
         display = os.environ.get('DISPLAY')
-        list_avialable_drivers = \
-            getAvailableX11Drivers(prefix=self.Get('cl_chroot_path'))
-        if display and list_avialable_drivers:
+        list_available_drivers = \
+            getAvailableVideo(prefix=self.Get('cl_chroot_path'))
+        if display and list_available_drivers:
             reDriver = re.compile('|'.join(map(lambda x: "%s_drv.so"%x,
-                                               list_avialable_drivers)))
-            display_number = re.search(r':(\d+)\..*', display)
+                                               list_available_drivers)))
+            display_number = re.search(r':(\d+)(\..*)?', display)
+            reDriverName = re.compile(r'([^/]+)_drv.so')
             if display_number:
                 xorg_log_file = '/var/log/Xorg.%s.log' % \
                                 display_number.group(1)
                 if path.exists(xorg_log_file):
-                    matchStrs = [i for i in open(xorg_log_file)
-                                    if "drv" in i and reDriver.search(i)]
+                    matchStrs = \
+                        map(lambda x:x.group(1),
+                        filter(lambda x:x,
+                        map(reDriverName.search,
+                        filter(lambda x:"drv" in x and reDriver.search(x),
+                        readLinesFile(xorg_log_file)))))
                     if matchStrs:
-                        resDriver = re.search(r'([^/]+)_drv.so',
-                            matchStrs[-1])
-                        if resDriver:
-                            return resDriver.group(1)
+                        return matchStrs[-1]
 
         # analize /etc/X11/xorg.conf
         if path.exists(xorg_conf):
@@ -413,19 +415,15 @@ class fillVars(varsShare):
             if matchSect:
                 resDriver = re.search(r'^\S*Driver\s*"([^"]+)"',
                                       matchSect.group(0),re.S)
-                if resDriver and resDriver.group(1) in list_avialable_drivers:
+                if resDriver and resDriver.group(1) in list_available_drivers:
                     return resDriver.group(1)
 
         videoVal = self.getValueFromCmdLine("calculate","video")
         videoVal = {'i915':'intel'}.get(videoVal,videoVal)
         if not isPkgInstalled('xorg-server') or \
-            videoVal in list_avialable_drivers:
+            videoVal in list_available_drivers:
             return videoVal
-        workedModules = map(lambda x:x[0],
-                        filter(lambda x:x[1].isdigit() and int(x[1])>0,
-                        map(lambda x:x.split()[:3:2],
-                        open('/proc/modules','r'))))
-        return self.getVideoByDefault(list_avialable_drivers)
+        return self.getVideoByDefault(list_available_drivers)
 
     def get_os_x11_height(self):
         """Get screen height in pixeles"""
@@ -559,19 +557,7 @@ class fillVars(varsShare):
 
     def get_cl_kernel_uid(self):
         """Get UID of symlink kernel, initramfs and System.map"""
-        uuidpath = '/dev/disk/by-uuid'
-        if not os.access(uuidpath,os.R_OK):
-            return ""
-        uuidDevs = filter(path.islink,map(lambda x: path.join(uuidpath,x),
-                                          os.listdir(uuidpath)))
-        mapDevUuid = dict(map(lambda x:(path.normpath(path.join(uuidpath,
-                                                      os.readlink(x))),
-                                        path.basename(x)),
-                          uuidDevs))
-        if self.Get('os_root_dev') in mapDevUuid:
-            return mapDevUuid[self.Get('os_root_dev')][:8]
-        else:
-            return ""
+        return self.getKernelUid(self.Get('os_root_dev'))
 
     def get_cl_chroot_status(self):
         """Detect chroot mode by mtab content"""
diff --git pym/cl_opt.py pym/cl_opt.py
index 833677e..52b414a 100644
--- pym/cl_opt.py
+++ pym/cl_opt.py
@@ -282,7 +282,7 @@ class opt(optparse.OptionParser):
         }]
     variable_view = \
         [{'shortOption':"v",
-         'longOption':"vars",
+         'longOption':"show-variables",
          'action':'count',
          'help':_("print variables, if the two options is verbose "
                   "(added print hidden variables)")
@@ -290,11 +290,11 @@ class opt(optparse.OptionParser):
         {'longOption':"filter",
          'optVal':"FILTER",
          'help':_("filtered variables (as a regular expression is used *), \
-is used in conjunction with the options '-v --vars'")
+is used in conjunction with the options '-v --show-variables'")
         },
         {'longOption':"xml",
          'help':_("output variables in the format of XML, \
-is used in conjunction with the option '-v --vars'")
+is used in conjunction with the option '-v --show-variables'")
         }]
     variable_control = variable_set + variable_view
 
diff --git pym/cl_utils.py pym/cl_utils.py
index 5d4d51a..105da40 100644
--- pym/cl_utils.py
+++ pym/cl_utils.py
@@ -221,7 +221,10 @@ class process:
             else:
                 stdin=kwarg["stdin"].getStdout
         self.stdout = kwarg.get("stdout",PIPE)
-        self.envdict = kwarg.get("envdict",None)
+        self.envdict = kwarg.get("envdict",{})
+        if "lang" in kwarg:
+            self.envdict["LANG"] = kwarg.get('lang')
+        self.langc = "langc" in kwarg
 
         self.stderr = kwarg.get("stderr",PIPE)
         self.command = [command] + list(params)
@@ -364,7 +367,7 @@ class processProgress(process):
         pass
 
 def runOsCommand(cmd,in_str=None, env_dict=None):
-    """Выполняет внешнюю программу
+    """Run system command
 
     Параметры:
     cmd            внешняя программа
@@ -392,30 +395,17 @@ def runOsCommand(cmd,in_str=None, env_dict=None):
     return retcode, res
 
 def genpassword(passlen=9):
-    '''Вернуть случайный набор символов указанной длины
-
-    Параметры:
-    passlen     длина пароля который нужно сгенерировать
-
-    Возвращаемые параметры:
-    Сгенерированный пароль указанной длины
-    '''
-    res=''.join([choice(string.ascii_letters+string.digits)\
-        for i in xrange(passlen)])
-    return res
+    """Return random charset specified lenght (passlen)"""
+    return ''.join(map(lambda x:choice(string.ascii_letters+string.digits),
+                   xrange(0,passlen)))
 
 def getpathenv():
-    """Вернуть пути для запуска утилит"""
-    bindir=['/sbin','/bin','/usr/sbin','/usr/bin']
+    """Return path for run utilities"""
+    bindir=set(filter(path.exists,
+               ['/sbin','/bin','/usr/sbin','/usr/bin']))
     env=os.environ
-    if env and env.has_key('PATH'):
-        lpath=env['PATH'].split(":")
-        npath=[]
-        for dirname in bindir:
-            if path.exists(dirname) and dirname not in lpath:
-                npath.append(dirname)
-        lpath=npath+lpath
-        return ":".join(lpath)
+    envPath = set(env.get('PATH','').split(":")) | bindir
+    return ":".join(envPath)
 
 class MultiReplace:
     """MultiReplace function object
@@ -627,7 +617,6 @@ def isFstabMount(pathname,mapDevUuid={},listFstab=[]):
         absPath = "swap"
     else:
         absPath = path.abspath(pathname)
-    devuuid = '/dev/disk/by-uuid'
     if not mapDevUuid:
         mapDevUuid.update(getUUIDDict())
     # convert fstab to
@@ -649,6 +638,67 @@ def isFstabMount(pathname,mapDevUuid={},listFstab=[]):
            filter(lambda x: absPath in x and x[1] != "none",
            listFstab),[""]))[0]
 
+class SingletonParam(type):
+    def __init__(cls, name, bases, dict):
+        super(SingletonParam, cls).__init__(name, bases, dict)
+        cls.instance = {}
+
+    def __call__(cls,*args,**kw):
+        keyarg = args[0] if args else ""
+        if not keyarg in cls.instance:
+            cls.instance[keyarg] = super(SingletonParam, cls).__call__(*args, **kw)
+        return cls.instance[keyarg]
+
+class FStab(object):
+    """Data reader for fstab"""
+    __metaclass__ = SingletonParam
+    fstab_file = '/etc/fstab'
+    NAME, DIR, TYPE, OPTS, FREQ, PASSNO = range(0,6)
+
+    def __init__(self,fstab_file=None):
+        if fstab_file:
+            self.fstab_file = fstab_file
+        self.cache = []
+        self.rotateCache = []
+        self.dictUUID = getUUIDDict()
+        self.rebuildCache()
+
+    def rebuildCache(self):
+        """Rebuild cache from fstab file"""
+        self.cache = \
+            map(lambda x:map(lambda y:y.strip(),x.split()),
+            filter(lambda x:x and not x.lstrip().startswith("#"),
+            open(self.fstab_file,'r').read().split('\n')))
+        for data in self.cache:
+            convertDev = lambda x: path.realpath(x) if x.startswith('/') else x
+            data[0] = convertDev(self.dictUUID.get(data[0],data[0]))
+            data[1] = data[1] if data[2] != "swap" else "swap"
+        self.rotateCache = zip(*self.cache)
+    
+    def getBy(self,what=DIR,where=NAME,eq=None,noteq=None,allentry=False):
+        """Get data from fstab"""
+        if not eq is None:
+            filterfunc = lambda x: x[where] == eq
+        else:
+            filterfunc = lambda x: x[where] != noteq
+        res = map(lambda x:x[what],filter(filterfunc,self.cache))
+        if allentry:
+            return res
+        else:
+            return "" if not res else res[-1]
+
+    def getFields(self,*fields):
+        """Get all data by specifie fields"""
+        return zip(*reduce(lambda x,y:x+[self.rotateCache[y]],fields,[]))
+
+    def isExists(self,what=DIR,eq=None,noteq=None):
+        """Field with condition exist in fstab"""
+        if not eq is None:
+            filterfunc = lambda x: x[what] == eq
+        else:
+            filterfunc = lambda x: x[what] != noteq
+        return bool(filter(filterfunc,self.cache))
+
 def isMount(pathname):
     """В случае монтирования директории выдает другой примонтированный путь"""
     absPath = path.abspath(pathname)
@@ -805,6 +855,27 @@ def listDirectory(directory,fullPath=False):
         pass
     return []
 
+def getInstalledVideo(prefix="/"):
+    """Get installed video drivers"""
+    x11Drivers = path.join(prefix,"usr/lib/xorg/modules/drivers")
+    return map(lambda x:x[:-7],
+           filter(lambda x:x.endswith('_drv.so'),
+           listDirectory(x11Drivers)))
+
+def getDistfilesVideo(prefix="/"):
+    """Get video drivers from distfiles"""
+    distFiles = path.join(prefix,"usr/portage/distfiles")
+    return list(set(
+           map(lambda x:'fglrx' if x.startswith('ati-driver') else "nvidia",
+           filter(lambda x:x.startswith('ati-driver-installer') or
+                           x.startswith('NVIDIA-Linux'),
+           listDirectory(distFiles)))))
+
+def getAvailableVideo(prefix="/"):
+    """Get available video drivers (installed and maybe installed)"""
+    return list(set(getInstalledVideo(prefix=prefix) + \
+           getDistfilesVideo(prefix=prefix)))
+
 def readLinesFile(filename):
     """Read file by line"""
     try:
@@ -823,38 +894,34 @@ def readFile(filename):
             return open(filename,'r').read()
     except (OSError,IOError):
         pass
-    finally:
-        return ""
+    return ""
 
 def getUUIDDict(revers=False):
     """Get dict UUID -> dev"""
-    devuuid = '/dev/disk/by-uuid'
-    datafunc = lambda x,y: (x,y)
+    blkidProcess = process("/sbin/blkid","-s","UUID","-c","/dev/null")
     if revers:
         datafunc = lambda x,y: (y,x)
+    else:
+        datafunc = lambda x,y: (x,y)
+    DEV,UUID = 0,1
+    reSplit = re.compile('^([^:]+):.*UUID="([^"]+)"',re.S)
     return dict(
-        map(lambda x:datafunc("UUID=%s"%path.basename(x),
-                      path.normpath(path.join(devuuid,os.readlink(x)))),
-        filter(path.islink,
-        listDirectory(devuuid,fullPath=True))))
+        map(lambda x:datafunc("UUID=%s"%x[UUID],
+                     getUdevDeviceInfo(name=x[DEV]).get('DEVNAME',x[DEV])),
+        map(lambda x:x.groups(),
+        filter(lambda x:x,
+        map(reSplit.search,
+        blkidProcess)))))
 
 def detectDeviceForPartition(dev):
-    """Detect parent device for partition by /sys/block (sysfs)"""
-    reDeviceSplit = re.compile("^(.*/)?(.*?)(\d+)$")
-    device = map(lambda x:filter(lambda x:x in dev,
-                                 x[1]),
-                 os.walk('/sys/block'))
-    if device:
-        device = device[0]
-        parentdevices = \
-            filter(lambda x: path.split(dev)[-1] in \
-                reduce(lambda y,z:y+z[1],
-                       os.walk(path.join('/sys/block',x)),[]), device)
-        if parentdevices:
-            return parentdevices[0]
-    res = reDeviceSplit.search(dev)
-    if res:
-        return res.groups()[1]
+    """Detect parent device for partition by udev and return property"""
+    prop = getUdevDeviceInfo(name=dev)
+    if prop.get('DEVTYPE','') != 'partition':
+        return ''
+    parentpath = path.dirname(prop.get('DEVPATH',''))
+    if parentpath:
+        devProp = getUdevDeviceInfo(path=parentpath)
+        return devProp.get('DEVNAME','')
     return None
 
 def getProgPath(progname):
@@ -872,7 +939,7 @@ def getProgPath(progname):
         return False
 
 def checkUtils(*utils):
-    """Check utils and exit if it not found"""
+    """Check utils, exit if it not found and return fullpath"""
     retval = []
     for util in utils:
         utilPath = getProgPath(util)
@@ -965,8 +1032,91 @@ def getSquashList():
         return map(lambda x:{"lzma":"xz"}.get(x,x),
                list(set(usesSquashFs) & wantMethod))
 
+def addUdevInfo(prop):
+    """Function for compatibility with util-linux with version less
+    that 2.18
+    TODO: need realization, now only stub
+    
+    ID_PART_TABLE_TYPE
+    ID_PART_ENTRY_TYPE
+    ID_PART_ENTRY_NUMBER
+    """
+    return prop
+
+def getUdevDeviceInfo(path="",name=""):
+    """Get device info by syspath of name"""
+    udevadmCmd = getProgPath('/sbin/udevadm')
+    typeQuery = "--path" if path else "--name"
+    value = path if path else name
+    return addUdevInfo(dict(
+        filter(lambda x:x[0],
+        map(lambda x:x.partition("=")[0::2],
+        process(udevadmCmd,"info","--query","property",
+               typeQuery,value).read().split("\n")))))
+
+def countPartitions(devname):
+    """Count partition for specified device"""
+    syspath = getUdevDeviceInfo(name=devname).get('DEVPATH','')
+    if not syspath:
+        return 0
+    deviceName = path.basename(syspath)
+    if not syspath.startswith("/sys"):
+        syspath = pathJoin("/sys",syspath)
+    return len(filter(lambda x:x.startswith(deviceName),
+               listDirectory(syspath)))
+
+def getLvmPartitions(vg_name,lv_name,cache=[]):
+    """Get lvm partitions"""
+    if not cache:
+        pvdisplayCmd = getProgPath('/sbin/pvdisplay')
+        pvdata = process(pvdisplayCmd,"-C","-o",
+                         "vg_name,lv_name,pv_name","--noh")
+        if pvdata.success():
+            cache.extend(
+                filter(lambda x:x and len(x)==3,
+                map(lambda x:x.split(),
+                pvdata.read().split('\n'))))
+    if cache:
+        res = map(lambda x:x[2],
+              filter(lambda x:x[0]==vg_name and x[1]==lv_name,cache))
+        if res:
+            return res
+    return []
+
+def getPartitionDevice(syspath):
+    """Get real parent device by partition,lvm,mdraid"""
+    prop = getUdevDeviceInfo(path=syspath)
+    # real device
+    if prop.get('ID_TYPE',"") == "disk" and \
+       prop.get('DEVTYPE',"") == "disk":
+        return prop.get('DEVNAME',"")
+    # partition
+    if prop.get('DEVTYPE') == "partition":
+        return getPartitionDevice(path.dirname(syspath))
+    # md raid
+    if prop.get('MD_LEVEL',"").startswith("raid"):
+        if not syspath.startswith('/sys'):
+            syspathpath = pathJoin('/sys',syspath)
+        syspath = pathJoin(syspath,"md")
+        for rd in filter(lambda x:path.basename(x).startswith('rd'),
+            listDirectory(syspath,fullPath=True)):
+            rdBlockPath = path.join(rd,"block")
+            if path.exists(rdBlockPath):
+                return getPartitionDevice(path.realpath(rdBlockPath))
+        else:
+            return ""
+    # lvm
+    if prop.get('DM_LV_NAME',"") != "":
+        parts = getLvmPartitions(prop.get('DM_VG_NAME',''),
+                                 prop.get('DM_LV_NAME',''))
+        if parts:
+            propPartLvm = getUdevDeviceInfo(name=parts[0])
+            if 'DEVPATH' in propPartLvm:
+                return getPartitionDevice(propPartLvm['DEVPATH'])
+    return ""
+    
 def getAvailableX11Drivers(prefix="/"):
-    """Get available x11 drivers"""
+    """Get available x11 drivers (Depricated Function)"""
     xorg_modules_dir = path.join(prefix,'usr/lib/xorg/modules/drivers')
     return map(lambda x: x[:-7],
            filter(lambda x:x.endswith('_drv.so'),
@@ -1002,32 +1152,148 @@ def lspci(filtername=None,shortInfo=False):
                               'name':sfunc(device[3])}
     return retData
 
-def getUdevDeviceInfo(path="",name=""):
-    """Get device info by syspath of name"""
-    udevadmCmd = getProgPath('/sbin/udevadm')
-    typeQuery = "--path" if path else "--name"
-    value = path if path else name
-    return dict(
-        filter(lambda x:x[0],
-        map(lambda x:x.partition("=")[0::2],
-        process(udevadmCmd,"info","--query","property",
-               typeQuery,value).read().split("\n"))))
-
 def getPartitionSize(dev):
     """Get partition size"""
     SECTORSIZE=512
-    syspath = getUdevDeviceInfo(name=dev).get('DEVPATH','')
-    if syspath:
-        sizeFile = pathJoin("/sys",syspath,"size")
-        if path.exists(sizeFile):
-            size = float(open(sizeFile,'r').read().strip())*SECTORSIZE
-            suffix = ((1024**0,""),
-                      (1024**1,"KiB"),
-                      (1024**2,"MiB"),
-                      (1024**3,"GiB"),
-                      (1024**4,"TiB"),
-                      (1024**5,"PiB"))
-            suffix = filter(lambda x:size >=x[0],suffix)[-1]
-            if suffix:
-                return "%.1f %s"%(size/suffix[0],suffix[1])
+    sizeFile = pathJoin(dev,"size")
+    if path.exists(sizeFile):
+        size = float(open(sizeFile,'r').read().strip())*SECTORSIZE
+        suffix = ((1024**0,""),
+                  (1024**1,"KiB"),
+                  (1024**2,"MiB"),
+                  (1024**3,"GiB"),
+                  (1024**4,"TiB"),
+                  (1024**5,"PiB"))
+        suffix = filter(lambda x:size >=x[0],suffix)
+        if suffix:
+            suffix = suffix[-1]
+            return "%.1f %s"%(size/suffix[0],suffix[1])
     return "0"
+
+def getDeviceType(syspath):
+    """Get device type (disk,partition,lvm,raid)"""
+    prop = getUdevDeviceInfo(path=syspath)
+    # real device
+    if prop.get('ID_CDROM',""):
+        return "cdrom"
+    if prop.get('ID_TYPE',"") == "disk" and \
+       prop.get('DEVTYPE',"") == "disk":
+        return "disk"
+    # partition
+    if prop.get('DEVTYPE') == "partition":
+        return getDeviceType(path.dirname(syspath))+"-partition"
+    # md raid
+    if prop.get('MD_LEVEL',"").startswith("raid"):
+        if not syspath.startswith('/sys'):
+            syspathpath = pathJoin('/sys',syspath)
+        syspath = pathJoin(syspath,"md")
+        for rd in filter(lambda x:path.basename(x).startswith('rd'),
+            listDirectory(syspath,fullPath=True)):
+            rdBlockPath = path.join(rd,"block")
+            if path.exists(rdBlockPath):
+                return getDeviceType(path.realpath(rdBlockPath))+"-raid"
+        else:
+            return "loop"
+    # lvm
+    if prop.get('DM_LV_NAME',"") != "":
+        parts = getLvmPartitions(prop.get('DM_VG_NAME',''),
+                                 prop.get('DM_LV_NAME',''))
+        if parts:
+            propPartLvm = getUdevDeviceInfo(name=parts[0])
+            if 'DEVPATH' in propPartLvm:
+                return getDeviceType(propPartLvm['DEVPATH'])+"-lvm"
+    return "loop"
+
+def getRaidPartitions(raidpath):
+    """Get raid partitions"""
+    prop = getUdevDeviceInfo(path=raidpath)
+    raidParts = []
+    if prop.get('MD_LEVEL',"").startswith("raid"):
+        if not raidpath.startswith('/sys'):
+            raidpath = pathJoin('/sys',raidpath)
+        raidpath = pathJoin(raidpath,"md")
+        for rd in filter(lambda x:path.basename(x).startswith('rd'),
+                  listDirectory(raidpath,fullPath=True)):
+            rdpath = path.join(raidpath,rd,"block")
+            if path.exists(rdpath):
+                raidParts.append(
+                    getUdevDeviceInfo(path=path.realpath(rdpath)).get(
+                    "DEVNAME",''))
+    return filter(lambda x:x,raidParts)
+
+
+def getPartitionType(prop):
+    """Get type of dos part table (primary,extended or logical)"""
+    if prop.get('ID_PART_TABLE_TYPE') == 'dos':
+        partId = prop.get('ID_PART_ENTRY_TYPE','')
+        partNumber = prop.get('ID_PART_ENTRY_NUMBER','')
+        if partId and partNumber:
+            if partId == "0x5":
+                return "extended"
+            elif int(partNumber)>4:
+                return "logical"
+            else:
+                return "primary"
+    return prop.get('ID_PART_TABLE_TYPE','')
+
+def detectBuild(pathname,dictInfo):
+    """Detect build by root passwd 'root'"""
+    shadowPath = pathJoin(pathname,'/etc/shadow')
+    if r"root:$1$JMvNh5xg$VnV1DyJdTcwuZ0hp5YiJG0:14349:0:::::" in \
+        readFile(shadowPath):
+        dictInfo['type'] = ' assemble'
+    elif path.exists(pathJoin(pathname,"delta")) and \
+         path.exists(pathJoin(pathname,"workspace")):
+        dictInfo['type'] = " builder"
+        issue = readFile(pathJoin(pathname,'etc/gentoo-release'))
+        if "Server" in issue:
+            if "Scratch" in issue:
+                dictInfo['name'] = "CSS"
+            else:
+                dictInfo['name'] = "CDS"
+        elif "Desktop" in issue:
+            if "XFCE" in issue:
+                dictInfo['name'] = "CLDX"
+            elif "KDE" in issue:
+                dictInfo['name'] = "CLD"
+            elif "GNOME" in issue:
+                dictInfo['name'] = "CLDG"
+        elif "Scratch" in issue:
+            dictInfo['name'] = "CLS"
+    else:
+        dictInfo['type'] = ''
+    return dictInfo
+
+def getOsProberHash(getContentFunc=None):
+    """Get partition content by os-prober"""
+    os_prober = getProgPath('/usr/bin/os-prober')
+    if os_prober:
+        DEV,LONG,SHORT,TYPE = 0,1,2,3
+        osProberList = \
+            map(lambda x:[getUdevDeviceInfo(name=x[DEV]).get('DEVNAME',''),
+                          x[LONG],x[SHORT],x[TYPE]],
+            filter(lambda x:len(x)>=4,
+            map(lambda x:x.split(":"),
+            process(os_prober))))
+        for osRecord in osProberList:
+            if "Gentoo" in osRecord[SHORT] and getContentFunc:
+                osDescr = getContentFunc(osRecord[DEV],addFunc=detectBuild)
+                if "name" in osDescr and "march" in osDescr and \
+                   "build" in osDescr and "ver" in osDescr and \
+                   (osDescr["ver"] != "0" or osDescr["build"]):
+                    if osDescr['build']:
+                        osDescr['build'] = "-%s"%osDescr['build']
+                    else:
+                        osDescr['build'] = "-%s"%osDescr['ver']
+                    osRecord[SHORT] = "{name}-{march}{build}{type}".format(**osDescr)
+                else:
+                    osRecord[SHORT] = "Gentoo"
+            elif "Gentoo" in osRecord[SHORT] and "Calculate" in osRecord[LONG]:
+                osRecord[SHORT] = "Calculate"
+        osProberHash = \
+            dict(
+            map(lambda x:(x[DEV],x[SHORT]),
+            osProberList))
+    else:
+        osProberHash = {}
+    return osProberHash
diff --git pym/cl_vars_share.py pym/cl_vars_share.py
index 755ae89..29274c5 100644
--- pym/cl_vars_share.py
+++ pym/cl_vars_share.py
@@ -16,7 +16,7 @@
 
 import os
 import sys
-from cl_utils import getpathenv, runOsCommand, typeFile
+from cl_utils import getpathenv, runOsCommand, typeFile,process
 import re
 from os import path, R_OK
 try:
@@ -528,6 +528,16 @@ class varsShare:
                 if reRes:
                     return reRes[0]
 
+    def selectVar(self,selField,where="",eq=""):
+        """Select value from matrix variables
+
+        Example:
+        selectVar("os_disk_dev",where="os_disk_mount",eq="/")"""
+        res = filter(lambda x:x[1] == eq,
+              zip(self.Get(selField),
+                  self.Get(where))) or [("","")]
+        return res[0][0]
+
     def getVersionFromGentooFiles(self,systemroot):
         """Get version from gentoo files"""
         gentooFile = path.join(systemroot,"etc/gentoo-release")
@@ -582,16 +592,22 @@ class varsShare:
                         filter(lambda x:x[1].isdigit() and int(x[1])>0,
                         map(lambda x:x.split()[:3:2],
                         open('/proc/modules','r'))))
-        if "nvidia" in drivers_list:
-            defaultNvidia = "nvidia"
-        elif "nouveau" in workedModules:
+        if "nouveau" in workedModules:
             defaultNvidia = "nouveau"
+        elif "nvidia" in drivers_list:
+            defaultNvidia = "nvidia"
         else:
             defaultNvidia = "nv"
+        if "radeon" in workedModules:
+            defaultAti = "radeon"
+        elif "fglrx" in drivers_list:
+            defaultAti = "fglrx"
+        else:
+            defaultAti = "radeon"
         defaultDriver = {
             'vesa':'vesa',
             'nvidia':defaultNvidia,
-            'ati':'fglrx' if "fglrx" in drivers_list else "radeon",
+            'ati':defaultAti,
             'intel':'intel',
             'via':'via',
             'vmware':'vmware'}
@@ -601,3 +617,13 @@ class varsShare:
             return defaultDriver[hr_video]
         else:
             return "vesa"
+
+    def getKernelUid(self,device):
+        """Get Kernel UID by UUID of device"""
+        blkidProcess = process('/sbin/blkid','-c','/dev/null','-s','UUID',
+                                '-o','value',device)
+        res = blkidProcess.read().strip()
+        if res:
+            return res[:8]
+        else:
+            return "no_uid"
